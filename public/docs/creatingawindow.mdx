# 윈도우 창 만들기

멋진 그래픽을 만들기 전에 우리가 해야할 첫번째 일은 OpenGL 컨텍스트와 그래픽을 그릴 애플리케이션 창(Window)를
만드는 것입니다. 하지만 이러한 작업들은 운영 체제마다 방식이 다르기 때문에 OpenGL은 일부러 이런 작업들에 개입하지 않습니다.
즉 창 생성, 컨텍스트 정의, 사용자 입력 처리 등은 개발자가 직접 구현해야 합니다.
다행히도, 우리가 필요한 기능을 제공해주는 라이브러리들이 많습니다. 일부는 OpenGL 전용으로 만들어진 것도 있습니다.
이러한 라이브러리들은 운영체제에 따라 다른 복잡한 작업들을 대신 처리해주고, 우리가 사용할 수 있는 윈도우 창과 OpenGL 컨텍스트를 제공해 줍니다.

대표적인 라이브러리로는

<List items={["GLUT","SDL","SFML","GLFW"]} ordered={true} />

등이 있습니다.

우리는 그중에서 **GLFW** 를 사용할 것입니다. 다른 라이브러리를 사용하셔도 괜찮습니다.
대부분의 설정은 GLFW의 것과 비슷할 것입니다.


## GLFW

GLFW는 C로 작성된 라이브러리 입니다. OpenGL만을 타겟으로 하였습니다.
GLFW는 화면에 그래픽을 렌더링 하는데 필요한 기본적인 필수 요소들을 제공합니다.
예를 들어, OpenGL 컨텍스트 생성, 윈도우 설정, 사용자 입력 처리 등을 지원하며
우리가 원하는 작업을 하기에는 충분합니다.

이번 장과 다음 장의 목표는 다음과 같습니다.

<List items={["GLFW를 정상적으로 설치 및 실행 하는 것", "OpenGL 컨텍스트를 제대로 생성하고", "간단한 윈도우를 화면에 띄워 테스트 할 수 있게 만드는 것"]} ordered={true} />

이 장에서는 GLFW 라이브러리를 **다운로드 → 빌드 → 프로젝트에 연결(linking)** 하는 과정을
단계별로 자세히 설명합니다.

우리는 현재 시점 기준으로 Microsoft Visual Studio 2019 IDE를 사용합니다.
(※ 최신 버전의 Visual Studio에서도 과정은 거의 동일합니다)

만약 여러분이 Visual Studio가 아닌 다른 IDE를 사용하거나,
더 오래된 버전을 사용하더라도 큰 차이는 없으니 걱정하지 않으셔도 됩니다.

## GLFW 빌드하기

GLFW는 공식 웹사이트의 <LinkBlock url={"https://www.glfw.org/download.html"} text="다운로드 웹사이트"/> 에서 받을 수 있습니다.
GLFW는 이미 Visual Studio 2012부터 2019까지 사용 가능한 미리 컴파일된 바이너리 파일과 헤더 파일을 제공합니다.

하지만 여기서는 더 완전히 배우기 위해 스스로 GLFW를 컴파일 해볼 것입니다. 이를 통해 오픈 소스 라이브러리를 직접 컴파일 하는 과정을 맛볼 수 있습니다. 모든 라이브러리가 빌드된 결과물을 제공하는 것은 아니기에 후에 도움이 될 것 입니다.

이제 **Source Package** 를 다운해 봅시다.

<Warning>
우리는 모든 라이브러리를 64비트 바이너리(실행 파일)로 빌드할 것이므로, 만약 GLFW의 미리 컴파일된 바이너리를 사용할 경우에도 반드시 64비트용으로 다운로드해야 합니다.
</Warning>

Source Package 를 다운로드 한 후에는 압축을 풀고 그 안의 내용을 열어보세요
우리가 주의깊게 봐야할 것은 몇가지 핵심 파일입니다.

<List items={["컴파일 결과로 생성된 라이브러리 파일", "include 폴더 (헤더 파일들이 들어있음)"]} ordered={true}/>


소스 코드로 부터 직접 라이브러리를 컴파일하면, 해당 라이브러리가 내 CPU와 운영체제에 최적화된 형태로 만들어진 장점이 있습니다.
이는 미리 컴파일된 바이너리들이 제공하지 못하는 이점입니다.

하지만 소스 코드를 오픈소스로 제공할 경우 문제점은, 모든 개발자가 같은 IDE나 빌드 시스템을
사용하는 것이 아니기에 소스코드의 프로젝트 파일 `(.sin, .vcxproj 등)` 이 다른 사람의 개발환경에는 호환되지 않을 수 있습니다. (ex, Mac의 경우)

이럴 경우, 사람들은 각각 자신이 사용 하는 IDE나 빌드 시스템에 맞게 일일이 .c, .cpp ,.h 파일들을 직접 프로젝트로
구성해야 한다는 번거로움이 있습니다.

바로 이러한 문제를 해결하기 위해 등장한 도구가 바로 CMake입니다.

CMake는 다양한 플랫폼과 IDE에서 사용할 수 있도록,
공통된 방식으로 빌드 설정을 정의하고,
그 설정을 기반으로 각 IDE/플랫폼에 맞는 프로젝트 파일을 자동으로 생성해줍니다


## CMake

CMake는 유저의 입맛에 맞게 project/solution을 생성할 수 있는 툴 입니다. (예. Visual studio, Code::Blocks, Eclips) 미리 정의된 CMake 스크립트를 사용하여 
여러 소스 코드 파일에서 생성해줍니다. 이를 통해 우리는 GLFW의 소스 패키지로부터 Visual Studio 프로젝트 파일을 생성할 수 있고, 그 프로젝트 파일을 이용해 라이브러리를 컴파일 할수 있습니다. 

먼저 CMake를 다운로드하고 설치해야합니다. CMake는 자체적인 <LinkBlock url={"https://cmake.org/download/"} text="CMake 다운로드 웹사이트"/> 에서 받을 수 있습니다. 

CMake를 설치한 후에는 command line 혹은 GUI를 통해 실행할 수 있습니다. 복잡하게 하지 않기 위해 여기서는 GUI를 사용하도록 합시다. 

CMake는 소스코드 폴더와 바이너리 빌드용 폴더를 필요로 합니다. 
- 소스 코드 폴더 : 다운로드한 GLFW 소스 패키지의 루트 폴더를 선택
- 빌드 폴더 : build라는 새 폴더를 만들어 그 폴더를 선택합니다. 

![CMake](./images/getting-started/cmake.png)

소스코더 폴더와 빌드 폴더가 세팅된 후에는 **Configure** 버튼을 클릭해서 CMake가 필요한 설정과 소스 코드들을 읽을 수 있도록 합니다. 
그 후 우리는 프로젝트의 생성자를 선택해야합니다. 현재 Visual Studio 2019를 사용하고 있으니 Visual Studio 16 옵션을 선택할 것입니다. 
(Visual Studio 2019는 Visual Studio 16으로도 알려져 있습니다.) CMake는 그 후 가능한 빌드 옵션들을 보여줍니다. 
기본값은 그대로 두고 다시 **Configure** 버튼을 눌러 설정을 저장하면 됩니다. 
설정이 완료되면 **Generate** 버튼을 눌러 프로젝트 파일을 빌드 폴더 안에 생성합니다. 


### 컴파일

build 폴더 안에 보면 `GLFW.sln`이라는 파일이 생성되어 있을 것입니다.
이 파일을 Visual Studio 2019로 열어줍니다.

CMake가 이미 적절한 설정이 적용된 프로젝트 파일을 생성해주었기 때문에,
우리는 별다른 설정 없이 **그냥 솔루션을 빌드(build)**하기만 하면 됩니다.

CMake는 기본적으로 이 솔루션이 64비트 라이브러리로 컴파일되도록 자동 설정했을 것입니다.
이제 **솔루션 빌드(Build Solution)** 버튼을 클릭하세요.

그러면 다음 경로에 컴파일된 라이브러리 파일이 생성됩니다:

<DirectoryStructure 
  title="lib 파일 위치"
  items={[
    {
      "name": "build/",
      "description": "빌드 폴더",
      "children": [
        {
          "name": "src/",
          "description": "src 폴더",
          "children": [
            {
              "name": "Debug/",
              "description": "Debug 폴더",
              "children": [
                {
                  "name": "glfw3.lib",
                  "description": "lib 파일"
                }
              ]
            }
          ]
        }
      ]
    }
  ]}
/>

### 컴파일 후에 해야할 일

이제 이 라이브러리를 OpenGL 프로젝트에서 사용할 수 있도록
IDE가 이 파일과 헤더 파일을 찾을 수 있게 설정해야 합니다.

이를 위한 방법은 두 가지가 있습니다:

- IDE 혹은 컴파일러의 `/lib`와 `include` 폴더를 찾아서 `GLFW`의 `include` 폴더 안에 있는 컨텐츠들을
  `IDE`의 `/include` 폴더 안에 포함시킵니다. 그리고 동일하게 `glfw3.lib` 를 `IDE` 의 `/lib` 폴더에 넣습니다.
  이 방식도 작동은 하지만 추천하는 방식은 아닙니다. 라이브러리와 include 파일들을 관리하기가 어렵고,
  IDE나 컴파일러를 새로 설치하게 되면 이 과정을 처음부터 다시 해야 하는 번거로움이 생깁니다.

사용자가 원하는 위치에 새로운 디렉토리들을 생성하여, 외부 라이브러리들의 헤더 파일과 라이브러리 파일들을 따로 정리해두는 방식입니다. 이 디렉토리들을 IDE나 컴파일러에서 참조하도록 설정할 수 있습니다.
예를 들어, 하나의 폴더 안에 `/libs` 폴더와 `/include` 폴더를 만들어,
OpenGL 프로젝트에서 사용하는 모든 라이브러리 파일과 헤더 파일을 각각 저장할 수 있습니다.'
이렇게 하면 모든 서드파티 라이브러리들이 하나의 폴더에 정리되므로, 다른 컴퓨터에서도 쉽게 복사하거나 공유할 수 있어 관리가 훨씬 편해집니다. 다만 이 방법의 단점은, 새 프로젝트를 만들 때마다 IDE에 해당 폴더 경로를 수동으로 설정해줘야 한다는 점입니다.

필요한 파일들을 원하는 위치에 저장해두었다면, 이제 첫 번째 OpenGL + GLFW 프로젝트를 생성할 준비가 완료된 것입니다.

## 우리의 첫 프로젝트

먼저 Visual Studio를 실행하고, **새 프로젝트(New Project)** 를 만듭니다.
여러 옵션이 표시된다면 C++ 프로젝트를 선택하고,
**빈 프로젝트(Empty Project)** 를 선택하세요.
(프로젝트에 적절한 이름을 지정하는 것도 잊지 마세요!)

우리는 모든 작업을 **64비트** 환경에서 진행할 예정이지만,
Visual Studio의 기본 설정은 **32비트(x86)** 로 되어 있습니다.

따라서, 상단의 디버그(Debug) 옆 드롭다운 메뉴에서 x86을 x64로 변경해 주세요

![X64](./images/getting-started/x64.png)

이것이 끝나고 나면, 이제 우리의 첫 OpenGL application을 만들 워크스페이스가 생겼습니다!

## 🔗 링킹(Linking)

프로젝트에서 GLFW를 사용하려면, 라이브러리 파일(glfw3.lib)을 프로젝트에 연결(link) 해줘야 합니다.

링커 설정에서 glfw3.lib를 사용하겠다고 지정하면 되지만, 지금은 우리 프로젝트가 그 파일이 어디에 있는지 모르는 상태입니다.
왜냐하면 우리는 GLFW를 **다른 위치(외부 디렉토리)** 에 저장했기 때문입니다.

따라서, 먼저 해당 라이브러리가 있는 디렉토리를 프로젝트에 추가해야 합니다.

Visual Studio에서는
라이브러리 파일이나 헤더 파일을 찾을 때 참조할 디렉토리를 지정해줄 수 있습니다.

솔루션 탐색기(Solution Explorer)에서
프로젝트 이름을 오른쪽 클릭합니다.

속성(Properties)으로 들어가서
왼쪽 메뉴에서 VC++ 디렉터리(VC++ Directories)로 이동합니다.
(아래 이미지처럼 표시됨)

![vc_directories](./images/getting-started/vc_directories.png)

그다음부터는 직접 디렉토리를 추가해서
프로젝트가 어디에서 파일들을 검색해야 하는지 알 수 있도록 설정할 수 있습니다:

- 경로 텍스트 칸에 직접 경로를 입력하거나
- 오른쪽의 경로 항목을 클릭한 후 **편집(Edit...)** 옵션을 선택

이 과정을 Library Directories와 Include Directories 모두에 대해 적용해야 합니다.

이 설정 화면에서는 원하는 만큼 추가 디렉토리를 등록할 수 있으며,
그 이후부터는 Visual Studio가 헤더 파일과 라이브러리 파일을 찾을 때, 해당 디렉토리들도 함께 검색하게 됩니다.

![include_directories](./images/getting-started/include_directories.png)

GLFW의 Include 폴더를 디렉토리에 추가하고 나면,
이제 코드에서 다음과 같이 GLFW 헤더 파일들을 `<GLFW/...>` 형식으로 include할 수 있게 됩니다:

```cpp
#include <GLFW/glfw3.h>
```

라이브러리 디렉토리에 대해서도 마찬가지로 적용됩니다.

### GLFW를 프로젝트에 실제로 링크하기

Visual Studio가 필요한 모든 파일들을 찾을 수 있게 되었으니,
이제 GLFW를 프로젝트에 정식으로 링크할 차례입니다.

![linker_input](./images/getting-started/linker_input.png)

1. 프로젝트 속성으로 이동
2. 왼쪽 메뉴에서 Linker (링커) > Input (입력) 탭 선택
3. Additional Dependencies (추가 종속성) 항목에 아래와 같이 입력합니다.

```vbnet
glfw3.lib
opengl32.lib //윈도우일 경우
```

라이브러리를 링크하려면 링커에게 해당 라이브러리의 이름을 명시해주어야 합니다.
라이브러리 이름이 glfw3.lib이므로, 이를 Additional Dependencies 필드에 추가합니다
(직접 입력하거나 **Edit..** 옵션을 사용해서 추가할 수 있습니다).
이후부터 컴파일 시 GLFW가 링크됩니다.

GLFW 외에도 OpenGL 라이브러리도 함께 링크해주어야 하지만,
이 라이브러리는 운영 체제에 따라 다를 수 있습니다.

#### Windows에서의 OpenGL 라이브러리

Windows 환경에서는 OpenGL 라이브러리인 opengl32.lib가 Microsoft SDK에 기본 포함되어 있으며,
Visual Studio를 설치하면 자동으로 함께 설치됩니다.

이 장에서는 Visual Studio 컴파일러를 사용하고 있고 운영체제도 Windows이므로,
링커 설정에 opengl32.lib를 추가해주면 됩니다.

<Info>
참고로, 64비트용 OpenGL 라이브러리도 이름이 opengl32.lib로, 32비트 버전과 이름이 동일하다는 점은 다소 헷갈릴 수 있습니다.
</Info>

#### Linux에서의 OpenGL 라이브러리

Linux 시스템에서는 libGL.so 라이브러리를 링크해야 하며,
링커 설정에 -lGL 옵션을 추가하면 됩니다.

만약 해당 라이브러리를 찾을 수 없다면,
**Mesa, NVIDIA 또는 AMD 개발용 패키지(dev package)** 를 설치해야 할 수도 있습니다.

GLFW와 OpenGL 라이브러리를 추가한 후에는 GLFW를 위한 헤더파일을 다음과 같이 추가할 수 있습니다.

```cpp
#include <GLFW/glfw3.h>
```

<Info>
Linux에서 GCC로 프로젝트를 컴파일하는 사용자라면, 다음 명령줄 옵션들이 컴파일에 도움이 될 수 있습니다: -lglfw3 -lGL -lX11 -lpthread -lXrandr -lXi -ldl 해당 라이브러리들을 정확히 링크하지 않으면, 정의되지 않은 참조(undefined reference) 오류가 다수 발생할 수 있습니다.
</Info>

이것으로 GLFW의 설정 및 구성 과정이 모두 완료되었습니다.

## GLAD

아직 모든 준비가 끝난 것은 아닙니다.
마지막으로 해야 할 작업이 하나 더 남아 있습니다.

OpenGL은 사실 **표준/명세(specification)** 일 뿐이며,
이를 실제로 구현하는 것은 그래픽 카드 제조사(driver 제조사)의 역할입니다.
즉, OpenGL 명세를 기반으로 각 제조사가 자신들의 그래픽 카드에 맞는 드라이버를 직접 만들어야 합니다.

그 결과, OpenGL 드라이버는 버전에 따라 매우 다양하며,
대부분의 OpenGL 함수는 컴파일 시점에는 위치를 알 수 없고,
실행 시점(run-time)에 직접 요청(query)해서 가져와야 합니다.

따라서 개발자는 필요한 함수들의 실제 주소를 얻고,
그것들을 함수 포인터에 저장하여 나중에 호출할 수 있도록 해야 합니다.

이러한 함수 포인터의 주소를 얻는 작업은 운영체제마다 다릅니다.
예를 들어, Windows에서는 다음과 같은 방식으로 이 작업이 이루어집니다:

```cpp
// 함수 프로토타입 정의
typedef void (*GL_GENBUFFERS) (GLsizei, GLuint*);
// 함수를 찾아서 포인터에 지정
GL_GENBUFFERS glGenBuffers  = (GL_GENBUFFERS)wglGetProcAddress("glGenBuffers");
// 이제 함수를 부를 수 있습니다.
unsigned int buffer;
glGenBuffers(1, &buffer);
```

보시다시피, 이 코드는 꽤 복잡하게 보이며,
아직 선언되지 않은 필요한 OpenGL 함수들마다 일일이 이런 작업을 해야 한다는 것은 매우 번거로운 일입니다.

다행히도, 이러한 작업을 대신해주는 라이브러리들이 존재하며,
그 중에서도 GLAD는 가장 널리 사용되고 최신 상태로 유지되는 라이브러리입니다.

### GLAD 설정하기 (Setting up GLAD)

GLAD는 우리가 앞에서 언급한 번거로운 작업을 대신 처리해주는 오픈 소스 라이브러리입니다.
하지만 GLAD는 대부분의 일반적인 오픈소스 라이브러리들과는 조금 다른 방식으로 설정됩니다.

GLAD는 웹 서비스를 통해 원하는 OpenGL 버전에 맞춰 사용할 함수들을 지정하고,
해당 버전에 필요한 모든 OpenGL 함수들을 정의하고 로드하는 코드를 생성해줍니다.

#### ✅ 설정 단계:

- GLAD 웹 서비스로 이동합니다.
- Language(언어)를 C++로 설정합니다.
- API 항목에서 OpenGL 버전 3.3 이상을 선택합니다.
  (이 튜토리얼에서는 3.3을 사용하지만 더 높은 버전도 괜찮습니다)
- Profile은 반드시 Core로 설정하세요.
- "Generate a loader" 옵션이 체크되어 있는지 확인합니다.
- Extensions는 지금은 무시해도 됩니다.
- 설정이 끝나면 Generate 버튼을 클릭하여 라이브러리 파일들을 생성합니다.

<Warning>
⚠️ 꼭 https://glad.dav1d.de/의 GLAD1 버전을 사용하세요. GLAD2는 이 튜토리얼과 호환되지 않아 컴파일 오류가 발생할 수 있습니다
</Warning>

#### 📁 생성된 파일 구성

압축 파일을 풀면 다음과 같은 파일이 제공됩니다:

`include/glad/` 폴더
`include/KHR/` 폴더
`glad.c 파일`

- glad와 KHR 폴더를 include 디렉토리에 복사합니다.
  또는 프로젝트에서 해당 경로를 Include Directories에 추가해도 됩니다.
- glad.c 파일을 프로젝트에 소스 파일로 추가합니다.

이후 소스 코드 상단에 추가:

```cpp
#include <glad/glad.h>
```

이제 GLAD를 통해 OpenGL 함수들을 안전하게 사용할 수 있습니다.

컴파일 버튼을 눌렀을 때 에러가 발생하지 않는다면,
이제 다음 장으로 넘어갈 준비가 된 것입니다.

다음 장에서는 GLFW와 GLAD를 실제로 사용하여 OpenGL 컨텍스트를 설정하고 윈도우를 생성하는 방법을 다룰 것입니다.

그 전에 다음 사항들을 꼭 확인하세요:

- 모든 include 디렉터리와 라이브러리 디렉터리가 올바르게 설정되어 있는지
- 링커 설정에 입력한 라이브러리 이름이 실제 파일과 정확히 일치하는지

이제 본격적으로 OpenGL 프로그래밍을 시작할 준비가 끝났습니다!다음 장에서는 **GLFW와 GLAD를 실제로 사용하여 OpenGL 컨텍스트를 설정하고 윈도우를 생성하는 방법** 을 다룰 것입니다. 이제 본격적으로 OpenGL 프로그래밍을 시작할 준비가 끝났습니다!

## 📋 설정 완료 체크리스트

다음 장으로 넘어가기 전에 다음 사항들을 꼭 확인하세요:

<List items={[
  "GLFW include 폴더가 프로젝트에 추가되어 있는지",
  "GLAD include 폴더가 프로젝트에 추가되어 있는지", 
  "GLFW 라이브러리 폴더가 프로젝트에 추가되어 있는지",
  "Additional Dependencies에 glfw3.lib가 추가되어 있는지",
  "Additional Dependencies에 opengl32.lib가 추가되어 있는지",
  "glad.c 파일이 프로젝트에 소스 파일로 추가되어 있는지"
]} />

컴파일 버튼을 눌렀을 때 에러가 발생하지 않는다면, 이제 다음 장으로 넘어갈 준비가 된 것입니다.

## 추가 자료

<LinkBlock url="https://www.glfw.org/docs/latest/window_guide.html" text="GLFW: Window Guide" /> - GLFW 창을 설정하고 구성하는 방법에 대한 공식 가이드입니다.

<LinkBlock url="https://www.opengl-tutorial.org/miscellaneous/building-your-own-c-application/" text="Building applications" /> - 애플리케이션의 컴파일 및 링크 과정에 대한 유용한 정보와, 발생할 수 있는 다양한 오류 목록(및 해결 방법)을 제공합니다.

<LinkBlock url="https://wiki.codeblocks.org/index.php?title=Using_GLFW_with_Code::Blocks" text="GLFW with Code::Blocks" /> - Code::Blocks IDE에서 GLFW를 빌드하는 방법을 설명합니다.

<LinkBlock url="https://cmake.org/resources/" text="CMake 실행하기" /> - Windows와 Linux에서 CMake를 실행하는 방법에 대한 간단한 개요입니다.

<LinkBlock url="https://learnopengl.com/demo/autotools_tutorial.txt" text="Writing a build system under Linux" /> - Wouter Verholst가 작성한 autotools 튜토리얼로, Linux에서 빌드 시스템을 작성하는 방법을 다룹니다.

<LinkBlock url="https://github.com/Polytonic/Glitter" text="Polytonic/Glitter" /> - 관련 라이브러리들이 사전 구성된 간단한 보일러플레이트 프로젝트입니다. 라이브러리를 직접 빌드하지 않고 예제 프로젝트를 바로 사용하고 싶을 때 유용합니다.

<LinkBlock url="https://www.youtube.com/watch?v=XpBGwZNyUh0&list=LL" text="초기 설정 비디오 튜토리얼" /> - 초기 설정에 대한 유튜브 영상 가이드입니다.
