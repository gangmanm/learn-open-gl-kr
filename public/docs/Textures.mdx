# Textures 텍스처 

우리는 물체에 더 많은 디테일을 추가하기 위해, 각 정점마다 색상을 지정하여 흥미로운 이미지를 만들 수 있다는 것을 배웠습니다. 
하지만 꽤나 그럴싸한 결과를 얻으려면 매우  많은 정점을 사용해야하고 각 정점마다 색상 속성을 추가해야 합니다. 
이는 각 모델이 더 많은 정점과 색상 데이터가 필요하다는 의미이므로 상당한 오버헤드를 발생시킵니다. 

예술과들과 프로그래머들이 일반적으로 선호하는 방법은 <Green>텍스처(texture)</Green>을 사용하는 것입니다. 
텍스처는 2D 이미지 입니다. (1D와 3D 텍스처도 존재합니다) 택스처를 예를 들어 설명하자면
벽돌 이미지가 인쇄된 종이 조각을 3D 집 모형에 잘 감싸 붙여서, 마치 그 집이 실제로 돌로 된 외벽을 가진 것처럼 
보이게 만드는 것입니다. 

단일 이미지 안에 많은 디테일을 담을 수 있기 때문에, 우리는 추가 정점을 만들지 않고도 물체가 매우 정교한
디테일을 가진 것처럼 보이게 할 수 있습니다. 

<Info>
이미지 뿐만 아니라 텍스처는 쉐이더로 전달하기 위한 방대한 양의 임의 데이터(arbitary data)를 저장하는
데에도 사용할 수 있습니다. 하지만 이부분은 다른 주제에서 다루도록 하겠습니다
</Info>

아래에서 전 장의 삼각형에 <LinkBlock url="https://learnopengl.com/img/textures/wall.jpg" text="벽돌 벽"/> 텍스처 이미지가 매핑된걸 볼 수 있습니다.

![textures](./images/getting-started/textures.png)


삼각형에 텍스처를 입히려면 삼각형의 각 정점이 텍스처의 어느 부분에 대응되는지를 알려주어야 합니다. 
따라서 각 정점에는 <Green>텍스처 좌표(Texture Coordinate)</Green>이 함께 있어야 하며, 이 좌표는 텍스처 이미지의 
어떤 부분을 샘플링 할지 지정합니다. 이후 나머지 프래그먼트들은 보간(interpolation)을 통해 자동으로 채워집니다. 


텍스처 좌표는 x축과 y축에서 0에서 1 사이의 값을 사용합니다.(우리는 2D 텍스처 이미지를 사용하고 있다는걸 기억하세요)
텍스처 좌표를 사용해 텍스처 색상을 가져오는 과정을 <Green>샘플링(Sampling)</Green>이라고 부릅니다. 
텍스처 좌표의 시작점은 `(0,0)` 이므로 텍스처 이미지의 왼쪽 아래 모서리를 의미하고, `(1.1)`은 오른쪽 위 모서리를 의미합니다. 

아래 그림은 텍스처 좌표를 삼각형에 매핑하는 방식을 보여줍니다. 

![tex_coords](./images/getting-started/tex_coords.png)

삼각형에 대해 세 개의 텍스처 좌표점을 지정합니다. 삼각형의 왼쪽 아래 부분이 텍스처의 왼쪽 아래 부분에 대응되길 원하므로,
삼각형의 왼쪽 아래 정점에는 `(0.0)` 텍스처 좌표를 사용합니다. 같은 방식으로, 삼각형의 오른쪽 아래 부분은 `(1.0)`텍스처 좌표를 사용합니다.
삼각형의 위쪽 정점은 텍스처 이미지의 위쪽 중앙에 대응되도록 해야하므로 해당 정점에는 `(0.5,1.0)` 텍스처 좌표를 지정합니다. 

우리가 해야할 일은 오직 이 3개의 텍스처 좌표를 정점 쉐이더에 전달하는 것 뿐입니다. 
정점 쉐이더는 이 좌표들을 프래그먼트 쉐이더로 넘기며, 프래그먼트 쉐이더는 모든 프래그먼트에 대해 텍스처 좌표를 깔끔하게 보간(interpolation)해 줍니다. 


<Collapsible title="보간(interpolation) 이란" variant="info">

### 보간 (interpolation)

보간이란 GPU가 삼각형 안쪽의 값들을 자동으로 채워 넣는 과정입니다. 
정점(모서리)에서만 값을 줘도, 그 사이 픽셀(프래그먼트)들의 값을 부드럽게 이어 계산해 줍니다. 텍스터 좌표, 색, 법선 같은
정점 속성들이 보간을 통해 픽샐 단위로 자연스럽게 퍼집니다. 

#### 보간이 일어나는 곳 

- 정점 쉐이더 (Vertex Shader) -> 레스터화 -> 프래그먼트 쉐이더 사이 즉 레스터화 단계에서 일어납니다. 
- 정점 쉐이더가 `out`으로 내보낸 값 (예: `vColor`)은 프래그먼트 쉐이더의 `in`으로 들어가는데 이때 삼각형 내부 위치에 따라 자동 보간 됩니다. 

</Collapsible>

그 결과 텍스처 좌표는 다음과 같이 나타납니다. 

```cpp
float texCoords[] = {
    0.0f, 0.0f,  // lower-left corner  
    1.0f, 0.0f,  // lower-right corner
    0.5f, 1.0f   // top-center corner
};
```

**텍스처 샘플링** 은 해석이 비교적 자유롭고 여러 방식으로 이루어질 수 있습니다. 따라서 OpenGL에 우리가 원하는 **샘플링** 방식을 직접 알려주어야 합니다. 

### Texture Wrapping 텍스처 래핑 
텍스처 좌표는 보통 `(0.0)` 에서 `(1.1)` 사이에 있지만 만약 이 범위를 벗어난 좌표를 지정하면 어떻게 될까요?

OpenGL의 기본 동작은 텍스처 이미지를 반복하는 것입니다.(부동소수점 텍스처 좌표의 정수 부분은 무시됨), 하지만 OpenGL은 그 외에도 
다양한 옵션을 제공합니다. 


<Collapsible title="부동소수점 텍스처 좌표의 정수 부분은 무시됨이란?" variant="info">

텍스처 좌표는 보통 0.0 ~ 1.0 사이에 있어야 합니다. 
만약 그 범위를 벗어난 좌표인 `(1.2,0.3)` , `(2.7,1.5)` 등을 주면 이 범위를 벗어나기 때문에 
OpenGL의 기본 모드에서는 좌표에서 정수 부분은 버리고, 소수 부분만 사용합니다. 
`(1.2,0.3)` -> `(0.2,0.3)` , `(2.7,1.5)` -> `(0.7,0.5)`

</Collapsible>


 - <Blue>GL_REPEAT</Blue> : 텍스처의 기본 동작, 텍스처 이미지를 반복합니다. 
 - <Blue>GL_MIRRORED_REPEAT</Blue> : <Blue>GL_REPEAT</Blue>와 동일하지만, 각 반복마다 이미지를 좌우로 반전시켜서 반복합니다.
 - <Blue>GL_CLAMP_TO_EDGE</Blue>: 좌표를 0과 1 사이로 고정(clamp) 함니다. 결과적으로 범위를 벗어난 좌표는 가장자리에 고정되며,
 텍스처 가장자리가 늘어난 패턴처럼 보입니다. 
 - <Blue>GL_CLAMP_TO_BORDER</Blue>: 범위를 벗어난 좌표에는 사용자가 지정한 경계(border) 색상을 사용합니다. 

 각 옵션은 텍스처 좌표가 기본 범위를 벗어났을 때 서로 다른 시각적 결과를 보여줍니다. 아래 그림은 예제 텍스처 이미지에 
 이러한 옵션들을 적용한 모습입니다. ( 원본 이미지 제공: Hólger Rezende)

![texture_wrapping](./images/getting-started/texture_wrapping.png)

앞서 설명한 각각의 옵션들은 좌표 축 마다 