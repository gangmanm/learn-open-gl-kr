# Textures 텍스처 

우리는 물체에 더 많은 디테일을 추가하기 위해, 각 정점마다 색상을 지정하여 흥미로운 이미지를 만들 수 있다는 것을 배웠습니다. 
하지만 꽤나 그럴싸한 결과를 얻으려면 매우  많은 정점을 사용해야하고 각 정점마다 색상 속성을 추가해야 합니다. 
이는 각 모델이 더 많은 정점과 색상 데이터가 필요하다는 의미이므로 상당한 오버헤드를 발생시킵니다. 

예술과들과 프로그래머들이 일반적으로 선호하는 방법은 <Green>텍스처(texture)</Green>을 사용하는 것입니다. 
텍스처는 2D 이미지 입니다. (1D와 3D 텍스처도 존재합니다) 택스처를 예를 들어 설명하자면
벽돌 이미지가 인쇄된 종이 조각을 3D 집 모형에 잘 감싸 붙여서, 마치 그 집이 실제로 돌로 된 외벽을 가진 것처럼 
보이게 만드는 것입니다. 

단일 이미지 안에 많은 디테일을 담을 수 있기 때문에, 우리는 추가 정점을 만들지 않고도 물체가 매우 정교한
디테일을 가진 것처럼 보이게 할 수 있습니다. 

<Info>
이미지 뿐만 아니라 텍스처는 쉐이더로 전달하기 위한 방대한 양의 임의 데이터(arbitary data)를 저장하는
데에도 사용할 수 있습니다. 하지만 이부분은 다른 주제에서 다루도록 하겠습니다
</Info>

아래에서 전 장의 삼각형에 <LinkBlock url="https://learnopengl.com/img/textures/wall.jpg" text="벽돌 벽"/> 텍스처 이미지가 매핑된걸 볼 수 있습니다.

![textures](./images/getting-started/textures.png)


삼각형에 텍스처를 입히려면 삼각형의 각 정점이 텍스처의 어느 부분에 대응되는지를 알려주어야 합니다. 
따라서 각 정점에는 <Green>텍스처 좌표(Texture Coordinate)</Green>이 함께 있어야 하며, 이 좌표는 텍스처 이미지의 
어떤 부분을 샘플링 할지 지정합니다. 이후 나머지 프래그먼트들은 보간(interpolation)을 통해 자동으로 채워집니다. 


텍스처 좌표는 x축과 y축에서 0에서 1 사이의 값을 사용합니다.(우리는 2D 텍스처 이미지를 사용하고 있다는걸 기억하세요)
텍스처 좌표를 사용해 텍스처 색상을 가져오는 과정을 <Green>샘플링(Sampling)</Green>이라고 부릅니다. 
텍스처 좌표의 시작점은 `(0,0)` 이므로 텍스처 이미지의 왼쪽 아래 모서리를 의미하고, `(1.1)`은 오른쪽 위 모서리를 의미합니다. 

아래 그림은 텍스처 좌표를 삼각형에 매핑하는 방식을 보여줍니다. 

![tex_coords](./images/getting-started/tex_coords.png)

삼각형에 대해 세 개의 텍스처 좌표점을 지정합니다. 삼각형의 왼쪽 아래 부분이 텍스처의 왼쪽 아래 부분에 대응되길 원하므로,
삼각형의 왼쪽 아래 정점에는 `(0.0)` 텍스처 좌표를 사용합니다. 같은 방식으로, 삼각형의 오른쪽 아래 부분은 `(1.0)`텍스처 좌표를 사용합니다.
삼각형의 위쪽 정점은 텍스처 이미지의 위쪽 중앙에 대응되도록 해야하므로 해당 정점에는 `(0.5,1.0)` 텍스처 좌표를 지정합니다. 

우리가 해야할 일은 오직 이 3개의 텍스처 좌표를 정점 쉐이더에 전달하는 것 뿐입니다. 
정점 쉐이더는 이 좌표들을 프래그먼트 쉐이더로 넘기며, 프래그먼트 쉐이더는 모든 프래그먼트에 대해 텍스처 좌표를 깔끔하게 보간(interpolation)해 줍니다. 


<Collapsible title="보간(interpolation) 이란" variant="info">

### 보간 (interpolation)

보간이란 GPU가 삼각형 안쪽의 값들을 자동으로 채워 넣는 과정입니다. 
정점(모서리)에서만 값을 줘도, 그 사이 픽셀(프래그먼트)들의 값을 부드럽게 이어 계산해 줍니다. 텍스터 좌표, 색, 법선 같은
정점 속성들이 보간을 통해 픽샐 단위로 자연스럽게 퍼집니다. 

#### 보간이 일어나는 곳 

- 정점 쉐이더 (Vertex Shader) -> 레스터화 -> 프래그먼트 쉐이더 사이 즉 레스터화 단계에서 일어납니다. 
- 정점 쉐이더가 `out`으로 내보낸 값 (예: `vColor`)은 프래그먼트 쉐이더의 `in`으로 들어가는데 이때 삼각형 내부 위치에 따라 자동 보간 됩니다. 

</Collapsible>

그 결과 텍스처 좌표는 다음과 같이 나타납니다. 

```cpp
float texCoords[] = {
    0.0f, 0.0f,  // lower-left corner  
    1.0f, 0.0f,  // lower-right corner
    0.5f, 1.0f   // top-center corner
};
```

**텍스처 샘플링** 은 해석이 비교적 자유롭고 여러 방식으로 이루어질 수 있습니다. 따라서 OpenGL에 우리가 원하는 **샘플링** 방식을 직접 알려주어야 합니다. 

### Texture Wrapping 텍스처 래핑 
텍스처 좌표는 보통 `(0.0)` 에서 `(1.1)` 사이에 있지만 만약 이 범위를 벗어난 좌표를 지정하면 어떻게 될까요?

OpenGL의 기본 동작은 텍스처 이미지를 반복하는 것입니다.(부동소수점 텍스처 좌표의 정수 부분은 무시됨), 하지만 OpenGL은 그 외에도 
다양한 옵션을 제공합니다. 


<Collapsible title="부동소수점 텍스처 좌표의 정수 부분은 무시됨이란?" variant="info">

텍스처 좌표는 보통 0.0 ~ 1.0 사이에 있어야 합니다. 
만약 그 범위를 벗어난 좌표인 `(1.2,0.3)` , `(2.7,1.5)` 등을 주면 이 범위를 벗어나기 때문에 
OpenGL의 기본 모드에서는 좌표에서 정수 부분은 버리고, 소수 부분만 사용합니다. 
`(1.2,0.3)` -> `(0.2,0.3)` , `(2.7,1.5)` -> `(0.7,0.5)`

</Collapsible>


 - <Blue>GL_REPEAT</Blue> : 텍스처의 기본 동작, 텍스처 이미지를 반복합니다. 
 - <Blue>GL_MIRRORED_REPEAT</Blue> : <Blue>GL_REPEAT</Blue>와 동일하지만, 각 반복마다 이미지를 좌우로 반전시켜서 반복합니다.
 - <Blue>GL_CLAMP_TO_EDGE</Blue>: 좌표를 0과 1 사이로 고정(clamp) 함니다. 결과적으로 범위를 벗어난 좌표는 가장자리에 고정되며,
 텍스처 가장자리가 늘어난 패턴처럼 보입니다. 
 - <Blue>GL_CLAMP_TO_BORDER</Blue>: 범위를 벗어난 좌표에는 사용자가 지정한 경계(border) 색상을 사용합니다. 

 각 옵션은 텍스처 좌표가 기본 범위를 벗어났을 때 서로 다른 시각적 결과를 보여줍니다. 아래 그림은 예제 텍스처 이미지에 
 이러한 옵션들을 적용한 모습입니다. ( 원본 이미지 제공: Hólger Rezende)

![texture_wrapping](./images/getting-started/texture_wrapping.png)

앞서 설명한 각각의 옵션들은 좌표 축 마다 설정할 수 있습니다. 즉 s,t (그리고 3D 텍스처를 사용할 경우 r축) 에 대해 
지정할 수있으며, 이는 각각 x,y,z 좌표에 해당합니다. 이러한 설정은 `glTexParameteri` 함수를 사용하여 설정할 수 있습니다. 

```cpp 

glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_MIRRORED_REPEAT);
glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_MIRRORED_REPEAT);
```

첫 번째 인자는 텍스처 타겟을 지정합니다. 우리는 2D 텍스처를 다루고 있으므로 텍스처 타깃은 <Blue>GL_TEXTURE_2D</Blue>를 사용합니다.
두 번째 인자는 어떤 옵션을 설정할지, 그리고 어떤 텍스처 축에 대해 적용할지를 지정해야 합니다. 여기서는 `S축` 과 `T축` 에 대해 설정합니다.
마지막 인자는 우리가 원하는 텍스처 래핑(Texture Wrapping) 모드를 전달해야 합니다. 위의 코드의 경우 OpenGL은 현재 활성화된 
텍스처의 래핑 옵션을 <Blue>GL_MIRRORED_REPEAT</Blue>로 설정합니다. 

만약 <Blue>GL_CLAMP_TO_BORDER</Blue> 옵션을 사용한다면, 경계 색(border color)도 지정해야 합니다. 
이는 `glTexParameterfv` 함수의 <Blue>GL_TEXTURE_BORDER_COLOR</Blue> 매개변수를 사용해 지정할 수 있습니다. 

```cpp 

float borderColor[] = { 1.0f, 1.0f, 0.0f, 1.0f };
glTexParameterfv(GL_TEXTURE_2D, GL_TEXTURE_BORDER_COLOR, borderColor);  
```

## Texture Filtering 텍스처 필터링 

텍스처 좌표는 해상도에 의존하지 않고 임의의 부동소수점 값이 될 수 있습니다.
따라서 OpenGL은 해당 텍스처 좌표를 어떤 텍스처 픽셀 <Green>(텍셀, texel)</Green>에 매핑할지 결정해야 합니다.
이것은 특히 아주 큰 객체에 낮은 해상도의 텍스처를 입히려 할때 중요해 집니다. 
아마 이미 짐작하셨겠지만, OpenGL은 이를 처리하기 위한 <Green>텍스처 필터링(Texture Filtering)</Green> 옵션을 제공합니다. 
다양한 필터링 옵션들이 있지만 우리는 가장 일반적인 두 가지인 <Blue>GL_NEAREST</Blue>와 <Blue>GL_LINEAR</Blue>을 살펴보겠습니다. 

<Blue>GL_NEAREST</Blue>은 (최근접 이웃, <Green>nearest neighbor</Green> 또는 <Green>point filtering</Green> 이라고도 불림) 은 OpenGL의 기본
텍스처 필터링 방식입니다. <Blue>GL_LINEAR</Blue>로 설정하면, OpenGL은 텍스처 좌표와 가장 가까운 중심을 가진 
텍셀(texel)을 선택합니다.  

아래 그림에서 십자가는 정확한 텍스처 좌표를 나타내고, 네 개의 픽셀(텍셀) 이 q보입니다. 
왼쪽 위 텍셀이 가장 텍스처 좌표와 가깝기 때문에 해당 텍셀이 샘플링된 색상으로 선택 됩니다. 

![filter_nearest](./images/getting-started/filter_nearest.png)


<Blue>GL_NEAER</Blue>는 (<Green>선형 보간((bi)linear filtering)</Green> 라고도 함) 텍스처 좌표 주변에 있는 여러 텍셀들의 값을 보간(interpolation) 하여,
그 사이 색상을 근사합니다. 텍스처 좌표가 어떤 텍셀의 중심에 가까울수록, 그 텍셀의 색상이 샘플링된 최종 색에 더 크게 반영됩니다. 

아래 그림에서 보듯이, 주변 픽셀들의 색상이 섞여서 최종적으로 반환되는 색상이 결정됩니다. 

![filter_linear](./images/getting-started/filter_linear.png)

하지만 이러한 텍스처 필터링 방법의 최종 모습은 어떨까요? 
이 방법들이 어떻게 보이는지 해상도가 낮은 이미지를 큰 물체에 매핑해서 알아봅시다(즉 텍스처가 확대되어 개별 텍셀이 눈에 띄는 경우)

![texture_filtering](./images/getting-started/texture_filtering.png)


<Blue>GL_NEAREST</Blue>은 텍스처를 구성하는 픽셀(텍셀)이 또렷하게 보이는 블록 형태의 패턴을 만들어 내고,
<Blue>GL_LINEAR</Blue>는 개별 픽셀이 덜 보이도록 더 매끄러운 패턴을 만듭니다. <Blue>GL_LINEAR</Blue>가 
더 현실적인 결과를 내지만, 일부 개발자는 8비트 게임 같은 느낌을 선호해 <Blue>GL_NEAREST</Blue>를 선택하기도 합니다. 

텍스처 필터링은 <Green>확대(magnify)</Green>와 <Green>축소(minify)</Green> 상황 (즉 스케일을 키우거나 줄일 때)
각각 설정할 수 있습니다. 예를 들어 축소할 때는 최근접(nearest) 필터링을 사용하고, 확대할 때는 선형(linear) 필터링을 사용할 수도 있습니다. 
따라서 두 경우 모두에 대해 `glTexParameteri`로 필터링 방법을 지정해야 하며, 코드는 래핑 방식 설정과 비슷한 형태가 됩니다. 

```cpp

glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
```


## Minmaps 밉맵

거대한 방 안에 수천개의 물체가 있고 , 각 물체에 텍스처가 붙어 있다고 상상해 봅시다. 
멀리 떨어져 있는 객체들도 가까운 객체와 똑같은 고해상도 텍스처를 사용하게 됩니다. 하지만 
멀리 있는 객체들은 화면상에서 몇 개의 프래그먼트만 차지할 뿐이고, 이 프래그먼트에 올바른 텍스처 색상을 
고해상도 텍스처에서 가져오기는 어렵습니다. 왜냐면 작은 프래그먼트가 사실상 텍스처의 많은 영역을 담아야 하기 때문입니다. 
이로 인해 작은 물체에는 눈에 띄는 아티팩트(artifact)가 발생할 수 있으며, 작은 물체에 고해상도 텍스처를 
적용하는 것은 메모리 대역폭 낭비이기도 합니다. 

이 문제를 해결하기 위해 OpenGL은 <Green>밉맵(mipmaps)</Green>라는 개념을 사용합니다. <Green> 밉맵(mipmaps)</Green>은 
기본적으로 여러장의 텍스처 이미지 집합으로, 각 텍스처는 이전 텍스처의 해상도보다 가로세로가 절반씩 작은 형태입니다. 
밉맵(mipmaps)의 아이디어는 간단합니다. 카메라로부터 일정 거리 이상 떨어진 객체에는, 그 거리에 가장 적합한 
크기의 밉맵(mipmaps) 텍스처를 사용하는 것입니다. 객체가 멀리 떨어져 있으므로 낮은 해상도를 사용해도 
사용자는 차이를 거의 알아차리지 못합니다. 

이렇게 하면 OpenGL은 올바른 텍셀(texel)을 샘플링할 수 있고, 밉맵(mipmaps)의 해당 부분을 샘플링할때 캐시 메모리
사용량도 줄어들게 됩니다. 이제 밉맵(mipmaps)이 적용된 텍스처가 어떻게 보이는지 알아봅시다. 


![mipmaps](./images/getting-started/mipmaps.png)

각 텍스처 이미지마다 밉맵 텍스처 집합을 직접 수동으로 만드는 것은 번거로운 일이지만, 다행이도 OpenGL은 우리가 텍스처를 생성한 뒤 `glGenerateMipmap` 한 줄만 호출하면 이 모든 작업을 자동으로 처리해 줍니다. 


렌더링 중 밉맵 레벨 사이를 전환할 때 OpenGL은 두 밉맵 레이어 사이 경계가 선명하게 보이는 등 
아티팩트(artifacts)가 생길 수 있습니다. 일반 텍스처 필터링 처럼 
밉맵 레벨 사이에서도 <Blue>NEAREST</Blue> 와 <Blue>LINEAR</Blue> 필터링을 사용해 
전환을 부드럽게 만들 수 있습니다. 밉맵 레벨 전환 시의 필터링 방식을 지정하려면 기존 필터링 옵션을 
아래 네 가지 중 하나로 바꾸면 됩니다. 

- <Blue>GL_NEAREST_MIPMAP_NEAREST</Blue> : 픽셀 크기와 가장 비슷한 밉맵을 선택하고 
텍스처 샘플링을 위해 최근접 보간(nearest neighbor interpolation)을 사용합니다.  
- <Blue>GL_LINEAR_MIPMAP_NEAREST</Blue> : 가장 크기가 비슷한 밉맵을 선택하고, 그 밉맵에서 
선형 보간(near interpolation)을 사용합니다.  
- <Blue>GL_NEAREST_MIPMAP_LINEAR</Blue> : 픽셀 크기와 가장 비슷한 두개의 밉맵 레벨 사이에서 
선형 보간을 수행한 뒤 , 보간된 레벨에서 최근접 보간을 사용합니다. 
- <Blue>GL_LINEAR_MIPMAP_LINEAR</Blue> : 픽셀 크기와 가장 비슷한 두 밉맵 레벨 사이에서, 선형 보간을 
수행한 뒤 보간된 레벨에서 선형 보간을 사용합니다. 

일반 텍스처 필터링을 설정하는 것과 동일하게 `glTexParameteri`를 통해 위 네 가지 중 하나의 방법을 필터링 옵션으로 지정할 수 있습니다. 

```cpp 
glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR_MIPMAP_LINEAR);
glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
```

일반적인 실수 중 하나는 확대 필터(magnfication filter)에 밉맵 필터링 옵션을 
설정하는 것입니다. 이렇게 해도 효과가 적용되지 않습니다. 왜냐하면 밉맵은 주로 텍스처가 
축소될 때 사용되기 때문입니다. 텍스처 확대에서는 밉맵을 사용하지 않으며, 확대 필터에 밉맵 필터링 옵션을 
지정하면 OpenGL에서 <Blue>GL_INVALID_ENUM</Blue> 오류를 발생시킵니다. 

<Collapsible title="아티팩트(artifact) 이란" variant="info">

### 아티팩트(artifact)란?

컴퓨터 그래픽스에서 아티팩트는 원래 의도하지 않았는데 화면에 생겨버린 이상한 현상이나 깨짐 현상을 의미합니다 
아티팩트 = “기술적 한계나 오류 때문에 생기는 원하지 않는 시각적 결과”

</Collapsible>

## Loading and Creating textures 텍스처를 만들고 가져오기 

텍스처를 실제로 사용하려면 가장 먼저 해야할 일은 이미지를 애플리케이션으로 불러오는 것입니다. 텍스처 이미지는 
수십가지 파일 형식으로 저장될 수 있으며, 각기 다른 데이터 구조와 순서를 가지고 있습니다. 
그렇다면 이런 이미지들을 애플리케이션에 어떻게 가져올 수 있을까요?

하나의 방법은 사용할 파일 형식을 하나 고르고(예:PNG) 그 이미지를 큰 바이트 배열로 변환할 수 있는 
이미지 로더(image loader) 를 직접 작성하는 것입니다. 사실 이미지 로더를 직접 만드는 것은 그렇게 어렵지는 않지만
번거롭습니다. 그리고 더 많은 파일 형식을 지원하게 된다면 어떻게 될까요?그렇게 되면 각 형식마다 이미지 로더를 
따로 작성해야한다는 문제가 있습니다. 

좀 더 나은 방법 (아마 가장 좋은 방법)은 여러 인기 있는 텍스처 포맷을 지원하고 복잡한 작업을 대신 처리해주는 이미지
로딩 라이브러리를 사용하는 것입니다. 대표적인 라이브러리로는 `stb_image.h` 가 있습니다.

### std_image.h 

`std_image.h` 는 <LinkBlock url="https://github.com/nothings" text="Sean Barrett"/>  가 만든 아주 인기 있는 단일 헤더 이미지 
로딩 라이브러리 입니다. 대부분의 유명한 이미지 파일 형식을 불러올 수 있으며, 프로젝트에 통합하기도 쉽습니다. 
`std_image.h`는  <LinkBlock url="https://github.com/nothings/stb/blob/master/stb_image.h" text="여기"/> 에서 다운로드 할 수 있습니다. 
다운로드한 단일 헤더 파일을 프로젝트에 `std_image.h` 라는 이름으로 추가한 뒤 , 별도의 C++ 파일을 만들고 아래 코드를 작성합니다. 

```cpp 

#define STB_IMAGE_IMPLEMENTATION
#include "stb_image.h"
```

<Blue>STB_IMAGE_IMPLEMENTATION</Blue> 을 정의하면, 전처리기가 헤더 파일을 수정하여 실제로 필요한 
정의 소스 코드만 포함되도록 합니다. 사실상 헤더 파일을 하나의 `.cpp` 파일로 만들어 줍니다. 
이제 다 됐습니다. 이제 프로그램 어딘가에 단순히 `stb_image.h` 를 포함하고 컴파일 하면 됩니다. 

다음 텍스처 예제에서는  <LinkBlock url=" https://learnopengl.com/img/textures/container.jpg" text="나무 상자"/>를 사용할 예정입니다. 
`std_image.h`를 이용해 이미지를 불러오기 위해서는 <Red>stbi_load</Red> 함수를 사용합니다.  

```cpp 
int width, height, nrChannels;
unsigned char *data = stbi_load("container.jpg", &width, &height, &nrChannels, 0); 
```

이 함수는 첫번째 인자로 이미지 파일의 위치를 받습니다. 그 다음 두 번째, 세 번째, 네 번째 인자로 `int` 변수 3개를 넘겨주면, `std_image.h`가 불러온
이미지의 가로(width), 세로(height), 그리고 색상 채널 수(number of color channels) 를 채워 넣습니다. 

우리는 이 이미지의 가로/세로 크기를 나중에 텍스처를 생성할때 사용하게 될 것입니다. 

## Generating a texture 텍스처 생성하기 

이전의 OpenGL 객체들과 마찬가지로, 텍스처도 ID로 참조됩니다. 먼저 텍스처 ID를 생성해봅시다. 

```cpp 

unsigned int texture;
glGenTextures(1, &texture);  
```

`glGenTextures` 함수는 첫번째 인자로 생성할 텍스처의 개수를 받고, 두 번째 인자로 전달된 `unsigned int` 배열에 
생성된 텍스처 ID를 저장합니다. (여기서는 하나의 텍스처만 생성), 다른 객체들과 마찬가지로, 생성한 텍스처를 
바인딩해야 이후의 텍스처 관련 명령어들이 현재 바인딩된 텍스처를 설정하게 됩니다. 

```cpp 
glBindTexture(GL_TEXTURE_2D, texture);  

```

이제 텍스처가 바인딩 되었으므로, 앞서 불러온 이미지 데이터를 사용해 텍스처를 생성할 수 있습니다. 텍스처는 
`glTexImage2D` 함수를 사용해 생성합니다.

이는 꽤나 크고 여러 매개변수를 가진 함수입니다. 그러니 하나하나 짚어보도록 하죠 

- 첫번째 인자: 텍스처 타깃을 지정합니다. 여기서는 <Blue>GL_TEXTURE_2D</Blue>를 설정했으므로 , 현재 바인딩된 2D 텍스처에 
이미지가 적용됩니다.(<Blue>GL_TEXTURE_1D</Blue>와 <Blue>GL_TEXTURE_3D</Blue>에는 영향을 주지 않음)
- 두번째 인자: 생성할 밉맵 레벨을 지정합니다. 보통 기본 레벨인 0을 사용합니다. 
- 세 번째 인자: OpenGL에 텍스처를 어떤 형식으로 저장할지 지정합니다. 이미지는 RGB 값만 있으므로 <Blue>GL_RGB</Blue>를 사용합니다. 
- 네 번째/ 다섯 번째 인자: 텍스처의 가로(width), 세로(height) 크기를 지정합니다. 이를 우리는 이미지를 가져올 때 저장했었으니 그것을 가져옵니다.
- 여섯 번째 인자: 항상 `0`으로 설정(레거시용)
- 일곱 번째/여덟 번째 인자: 원본 이미지의 형식과 데이터 타입을 지정합니다. 우리는 `RGB`값으로 불러왔고, 이를 `unsigned char(바이트)`
로 저장했으므로 이에 알맞는 값을 지정합니다. 
- 마지막 인자: 실제 이미지 데이터를 넘겨줍니다. 

`glTexImage2D`가 호출되면, 현재 바인딩된 텍스처 객체에 이미지가 연결됩니다. 다만 이 시점에서는 기본 레벨의 이미지 데이터만 적용됩니다. 
만약 밉맵을 사용하려면, 두번째인자를 증가시키며 직접 모든 밉맵 레벨을 지정하거나, `glGenerateMipmap`을 호출하여 필요한 밉맵을 자동으로 생성할 수 있습니다. 

텍스처와 밉맵 생성을 마친 후에는, 불필요한 이미지 메모리를 해제하는 것이 좋습니다. 
```cpp 
stbi_image_free(data);
```

텍스처를 생성하는 전체 과정은 다음과 같습니다. 

```cpp 
unsigned int texture;
glGenTextures(1, &texture);
glBindTexture(GL_TEXTURE_2D, texture);
// set the texture wrapping/filtering options (on the currently bound texture object)
glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);	
glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);
glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR_MIPMAP_LINEAR);
glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
// load and generate the texture
int width, height, nrChannels;
unsigned char *data = stbi_load("container.jpg", &width, &height, &nrChannels, 0);
if (data)
{
    glTexImage2D(GL_TEXTURE_2D, 0, GL_RGB, width, height, 0, GL_RGB, GL_UNSIGNED_BYTE, data);
    glGenerateMipmap(GL_TEXTURE_2D);
}
else
{
    std::cout << "Failed to load texture" << std::endl;
}
stbi_image_free(data);
```

## Applying textures 텍스처 적용하기 

다음 섹션들에서는 <LinkBlock url="https://learnopenglkr.com/#hellotriangle" text="Hello Triangle"/> 챕터 마지막 부분에서 `glDrawElements`로 그린 사각형 도형을 사용할 것입니다. 이제 OpenGL에 텍스처를 어떻게 샘플링 해야하는지 알려주어야 하므로, 정점 데이터(vertex data)에 
텍스처 좌표(texture coordinates)를 추가해야 합니다.


```cpp 
float vertices[] = {
    // positions          // colors           // texture coords
     0.5f,  0.5f, 0.0f,   1.0f, 0.0f, 0.0f,   1.0f, 1.0f,   // top right
     0.5f, -0.5f, 0.0f,   0.0f, 1.0f, 0.0f,   1.0f, 0.0f,   // bottom right
    -0.5f, -0.5f, 0.0f,   0.0f, 0.0f, 1.0f,   0.0f, 0.0f,   // bottom left
    -0.5f,  0.5f, 0.0f,   1.0f, 1.0f, 0.0f,   0.0f, 1.0f    // top left 
};
```

정점 속성(vertex attribte)를 추가했으니 다시 OpenGL에게 새로운 정점 형식을 알려주어야 합니다. 
![vertex_attribute_pointer_interleaved_textures](./images/getting-started/vertex_attribute_pointer_interleaved_textures.png)

```cpp 
glVertexAttribPointer(2, 2, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(6 * sizeof(float)));
glEnableVertexAttribArray(2);  
```

이전에 설정했던 두 개의 정점 속성(vertex attribute)에 대해서도 stride 파라미터를 `8*sizeof(float)`로 설정해야 한다는 점을 유의하세요

그 다음으로는, 정점 쉐이더(vertex shader)가 텍스처 좌표(texture coordinates)를 정점 속성으로 받아들일 수 있도록 수정하고,
이 좌표를 프래그먼트 쉐이더(fragment shader)로 전달해야 합니다.

```cpp 
#version 330 core
layout (location = 0) in vec3 aPos;
layout (location = 1) in vec3 aColor;
layout (location = 2) in vec2 aTexCoord;

out vec3 ourColor;
out vec2 TexCoord;

void main()
{
    gl_Position = vec4(aPos, 1.0);
    ourColor = aColor;
    TexCoord = aTexCoord;
}
```
프래그먼트 쉐이더는 이제 정점 쉐이더에서 전달된 `TexCoord` 출력 변수를 입력 면수로 받아야 합니다. 

또한 프래그먼트 쉐이더는 텍스처 객체(texture object)에 접근할 수 있어야 하는데 어떻게 전달하면 좋을까요? 

GLSL은 텍스처 객체를 위한 내장 타입 <Green>sampler</Green>을 제공합니다. 
이 타입은 우리가 사용하려는 텍스처의 종류에 따라 접미사를 뭍여 사용합니다. 
예를 들어 `sampler 1D`, `sampler 3D` 그리고 이번 경우에는 `sampler 2D`를 사용하겠죠 

따라서 프래그먼트 쉐이더에 단순히 `uniform sampler2D`를 선언하면 되고, 나중에 이 변수에 우리가 생성한 텍스처를 할당해 줄 수 있습니다. 


```cpp 
#version 330 core
out vec4 FragColor;
  
in vec3 ourColor;
in vec2 TexCoord;

uniform sampler2D ourTexture;

void main()
{
    FragColor = texture(ourTexture, TexCoord);
}
``` 
텍스처 색상을 샘플링 하기 위해서는 GLSL의 내장함수 <Red>texture</Red>를 사용합니다.  이 함수는 첫번째 인자로 
텍스처 샘플러(texture sampler =  쉐이더안에서 택스처에 접근할 수 있게 해주는 GLSL 변수 타입)를 받고, 두번째 인자로 텍스처 좌표를 받습니다. 
<Red>texture</Red> 함수는 우리가 이전에 설정한 텍스처 파라미터를 사용해 해당 좌표에서의 색상값을 샘플링(텍스처에서 색상값을 가져오는 것) 합니다. 

이 프래그먼트 쉐이더의 출력은 곧 보간된 텍스처 좌표에서 샘플링된 (필터링된) 텍스처 색상이 됩니다. 
이제 남은 일은 `glDrawElements` 함수를 호출하기 전에 텍스처를 바인딩 하는 것 뿐입니다. 그렇게 하면 OpenGL 이 
자동으로 텍스처를 프래그먼트 쉐이더의 샘플러에 할당합니다. 

```cpp 
glBindTexture(GL_TEXTURE_2D, texture);
glBindVertexArray(VAO);
glDrawElements(GL_TRIANGLES, 6, GL_UNSIGNED_INT, 0);
```

만약 모든걸 잘 수행했다면 다음과 같은 이미지가 보입니다. 


![container_textured](./images/getting-started/container_textured.png)

만약 사각형이 완전히 흰색이나 검은색으로만 보인다면, 아마도 중간에 오류가 있었을 가능성이 큽니다. 
쉐이더 로그(shader log)를 확인하고 자신의 코드를 <LinkBlock url="https://learnopengl.com/code_viewer_gh.php?code=src/1.getting_started/4.1.textures/textures.cpp" text="예제 코드"/>
와 비교해 보세요.

<Warning>
만약  텍스처 코드가 작동하지 않거나 화면에 완전히 검은색으로만 보인다면, 이 장의 마지막 예제까지 차근차근 따라가 보세요 
일부 드라이버에서는 각 샘플러 유니폼(sampler uniform)에 텍스처 유닛(texture unit)을 직접 지정해주어야 하는
경우가 있습니다. 이 부분은 이 장에서 더 자세히 다룰 예정입니다. 
</Warning>

조금 더 재미있게 하기 위해, 결과 텍스처 색상과 정점 색상을 섞을 수도 있습니다. 이를 위해서는 단순히 
프래그먼트 쉐이더(Fragment Shader)에서 결과 텍스처 색상에 정점 색상을 곱해주면 두 색상을 혼합할 수 있습니다. 

```cpp 
FragColor = texture(ourTexture, TexCoord) * vec4(ourColor, 1.0);  
```
결과는 다음과 같이 정점 색상과 텍스처 색상이 합해진 모습이어야 합니다. 

![container_textured2](./images/getting-started/container_textured2.png)

저희의 컨테이너가 이제는 디스코 처럼 보이네요 

## Texture Units 

아마 왜 `sampler2D` 변수가 `uniform`인지 궁금하셨을 겁니다. 우리는 `glUniform`을 사용하지도 않았으니까요
하지만 `glUniform1i`를 사용하면 텍스처 샘플러에 특정 location 값을 지정할 수 있고 이렇게 되면 프래그먼트 쉐이더에 
한번에 여러 텍스처를 동시에 사용할 수 있습니다. 이 텍스처의 location 값은 일반적으로 <Green>텍스처 유닛(texture uint)</Green> 이라고 부릅니다. 



<Collapsible title="location  이란?" variant="info">

OpenGL 에서 `location`은 크게 두 가지 맥락에서 쓰입니다. 

1. 쉐이더 입력 변수 (location = 레이아웃 위치)
```cpp 
layout (location = 0) in vec3 aPos;
layout (location = 1) in vec2 aTexCoord;
``` 
- 여기서 `location`은 어떤 슬롯 : 어떤 쉐이더 변수 에 넣을지 정하는 번호힙니다. 

layout(location = n) → 정점 속성(버퍼 데이터 ↔ 셰이더 입력) 연결용 번호.

2. Uniform 변수(location = GPU 내부 슬롯)
```glsl 
uniform sampler2D texture1;
...
glUniform1i(location, 0); // texture1 → 텍스처 유닛 0번에 연결
```

- 여기서 `location`은 쉐이더 안에서 uniform 변수가 GPU의 몇 번 자리에 배정되었는지를 뜻합니다. 

uniform location → GPU 안에서 uniform 변수를 찾아낼 때 쓰는 "주소 번호".

</Collapsible>

기본적으로 텍스처의 텍스처 유닛(Texture unit)은 `0`이고 이는 기본 활성화된 텍스처 유닛이기 때문에 
이전 섹션에서는 위치를 따로 할당할 필요가 없었습니다. 다만 모든 그래픽 들아ㅣ버가 기본 텍스처 유닛을 자동으로
지정 해주는 것은 아니기 때문에, 이전 섹션의 예제가 일부 환경에서는 렌더링 되지 낳았을 수도 있습니다. 

텍스처 유닛의 주요 목적은 쉐이더에서 2개 이상의 텍스처를 사용하는 것입니다. 샘플러에 텍스처 유닛을 지정해주면,
해당 유닛을 먼저 활성화시킨다는 조건 하에 여러 텍스처를 바인딩 할 수  있습니다. 

`glBindTexture`와 마찬가지로 우리는 `glActiveTexture`를 사용해 텍스처 유닛을 활성화시킬 수 있습니다.  

```cpp 
glActiveTexture(GL_TEXTURE0); // 텍스처를 바인딩하기 전에 먼저 텍스처 유닛을 활성화
glBindTexture(GL_TEXTURE_2D, texture);
```

특정 텍스처 유닛을 활성화한 뒤에 `glBindTexture`를 호출하면, 그 텍스처는 현재 활성화된 텍스처 유닛에 바인딩 됩니다. 
<Blue>GL_TEXTURE0</Blue> 은 항상 기본적으로 활성화 되어 있으므로 이전 예제에서는 `glBindTexture`를 사용할때 
텍스처 유닛을 따로 활성화할 필요가 없었습니다. 


<Info>
OpenGL은 최소 16개의 텍스처 유닛을 제공하므로 `GL_TEXTURE0` 부터 `GL_TEXTURE15` 까지 활성화해 사용할 수 있습니다.
이 값들은 순서대로 정의되어 있어서, 예를 들어 여러 텍스처 유닛을 반복문으로 다뤄야 할 때 `GL_TEXTURE0 + 8` 처럼 계산해서
`GL_TEXTURE8` 을 얻는 것도 가능합니다. 
</Info>

다만 프래그먼트 쉐이더가 추가 샘플러(sampler)를 받도록 수정해야 합니다. 이 작업은 비교적 간단합니다. 

```cpp

#version 330 core
...

uniform sampler2D texture1;
uniform sampler2D texture2;

void main()
{
    FragColor = mix(texture(texture1, TexCoord), texture(texture2, TexCoord), 0.2);
}
```

최종 출력 색상은 이제 두번의 텍스처 조회 결과를 조합한 것입니다. GLSL의 내장함수 <Red>mix</Red>는 
두 값을 입력으로 받아, 세 번째 인자에 따라 두 값 사이를 선형 보간합니다. 세 번째 값이 `0.0`이면 
첫번째 입력을 반환하고 `1.0`이면 두번째 입력을 반환합니다. 값이 `0.2`라면 첫번째 입력 색상 80%와 
두 번째 입력 색상 20%가 섞여 두 텍스처의 혼합 결과가 됩니다. 

이제 다른 텍스처를 하나를 더 로드하고 생성해 봅시다. 이 과정은 이미 익숙할 것입니다. 
새로운 텍스처 객체를 만들고, 이미지를 로드한 뒤 `glTexImage2D`로 최종 텍스처를 생성합니다. 두번째 텍스처로는 
<LinkBlock url="https://learnopengl.com/img/textures/awesomeface.png" text="OpenGL을 배우는 여러분의 모습"/> 이미지를 사용하겠습니다. 

```cpp 
unsigned char *data = stbi_load("awesomeface.png", &width, &height, &nrChannels, 0);
if (data)
{
    glTexImage2D(GL_TEXTURE_2D, 0, GL_RGB, width, height, 0, GL_RGBA, GL_UNSIGNED_BYTE, data);
    glGenerateMipmap(GL_TEXTURE_2D);
}
```

여기서는 알파(투명) 채널이 포함된 `.png`이미지를 로드합니다. 따라서 이미지 데이터에 알파 채널이 있음을 <Blue>GL_RGBA</Blue>로 지정해야합니다.
그렇지 않으면 OpenGL이 데이터를 잘못 해석하게 됩니다. 

두번째 텍스처(그리고 첫번째 텍스처)까지 사용하려면, 렌더링 절차에서 각 텍스처를 해당 텍스처 유닛에 바인딩하도록 약간 수정해야합니다. 

```cpp
glActiveTexture(GL_TEXTURE0);
glBindTexture(GL_TEXTURE_2D, texture1);
glActiveTexture(GL_TEXTURE1);
glBindTexture(GL_TEXTURE_2D, texture2);

glBindVertexArray(VAO);
glDrawElements(GL_TRIANGLES, 6, GL_UNSIGNED_INT, 0);
```
또한 각 쉐이더 샘플러가 어느 텍스처 유닛을 참조하는지 알려주어야 합니다. 
이는 `glUniform1i`로 설정하며, 렌더 루프에 들어가기 전에 한번만 설정하면 됩니다. 

```cpp
ourShader.use(); // 유니폼 설정 전에 셰이더 활성화 잊지 않기!
glUniform1i(glGetUniformLocation(ourShader.ID, "texture1"), 0); // 수동 설정
ourShader.setInt("texture2", 1); // 셰이더클래스 사용 예시 
  
while(...) 
{
    [...]
}

```

`glUniform1i`로 샘플러를 설정하면 각 `uniform sampler`(예: texture1,texture2)가 올바른 텍스처 유닛(예: GL_TEXTURE0,GL_TEXTURE2)에 
대응되도록 보장합니다. 이제 다음과 같은 결과를 얻을 수 있습니다. 

![textures_combined](./images/getting-started/textures_combined.png)

아마도 눈치 채셨겠지만, 텍스처가 거꾸로 되어있습니다. 이는 OpenGL이 이미지의 y축 `0.0` 좌표를 아래쪽으로 기대하는 반면
일반적인 이미지 포맷은 y축 `0.0`이 위쪽에 있기 때문입니다. 다행히 `std_image.h`는 이미지를 로드할대 y축을 
뒤집도록 설정할 수 있습니다. 어떤 이미지를 로드하기 전에 다음 문장을 추가하세요 

```cpp
stbi_set_flip_vertically_on_load(true);  
```

`std_image.h`가 이미지를 뒤집도록 했다면, 다음과 같은 결과를 보실 수 있습니다. 

![textures_combined2](./images/getting-started/textures_combined2.png)  


행복한 컨테이너가 보인다면 제대로 한 것입니다. <LinkBlock url="https://learnopengl.com/code_viewer_gh.php?code=src/1.getting_started/4.2.textures_combined/textures_combined.cpp" text="전체 코드"/>
와 비교해 보세요 

## 연습 문제(Exercises)

텍스처에 익숙해지기 위해 다음 연습을 하고 넘어가길 권합니다.

<NumberedList>
<NumberedItem>프래그먼트 셰이더를 수정해서, 웃는 얼굴(스마일) 만 반대 방향을 바라보도록 하세요: <LinkBlock url="https://learnopengl.com/code_viewer_gh.php?code=src/1.getting_started/4.3.textures_exercise1/textures_exercise1.cpp" text="해답답"/>.</NumberedItem>
<NumberedItem>텍스처 좌표를 0.0f ~ 1.0f 대신 0.0f ~ 2.0f 범위로 지정해 보며 텍스처 래핑(wrapping) 방식을 실험해 보세요. 에지에서 잘리도록(clamp) 설정해 하나의 컨테이너 이미지에 스마일 4개를 표시할 수 있는지 확인해 보세요: <LinkBlock url="https://learnopengl.com/code_viewer_gh.php?code=src/1.getting_started/4.4.textures_exercise2/textures_exercise2.cpp" text="해답"/>, <LinkBlock url="https://learnopengl.com/img/getting-started/textures_exercise2.png" text="결과"/>. 다른 래핑 방식도 실험해 보세요.</NumberedItem>
<NumberedItem>텍스처 좌표를 조정하여 사각형에 텍스처 이미지의 중앙 픽셀들만 표시하고, 픽셀이 크게 보이도록 해 보세요. 더 선명하게 보려면 텍스처 필터링을 <Blue>GL_NEAREST</Blue>로 설정해 보세요: <LinkBlock url="https://learnopengl.com/code_viewer_gh.php?code=src/1.getting_started/4.5.textures_exercise3/textures_exercise3.cpp" text="해답"/>.</NumberedItem>
<NumberedItem><Red>mix</Red> 함수의 세 번째 파라미터를 uniform 변수로 두고, 두 텍스처의 가시 비율을 조절해 보세요. 위/아래 화살표 키로 컨테이너와 스마일의 가시성을 바꿔보세요: <LinkBlock url="https://learnopengl.com/code_viewer_gh.php?code=src/1.getting_started/4.6.textures_exercise4/textures_exercise4.cpp" text="해답"/>.</NumberedItem>
</NumberedList>