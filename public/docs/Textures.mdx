# Textures 텍스처 

우리는 물체에 더 많은 디테일을 추가하기 위해, 각 정점마다 색상을 지정하여 흥미로운 이미지를 만들 수 있다는 것을 배웠습니다. 
하지만 꽤나 그럴싸한 결과를 얻으려면 매우  많은 정점을 사용해야하고 각 정점마다 색상 속성을 추가해야 합니다. 
이는 각 모델이 더 많은 정점과 색상 데이터가 필요하다는 의미이므로 상당한 오버헤드를 발생시킵니다. 

예술과들과 프로그래머들이 일반적으로 선호하는 방법은 <Green>텍스처(texture)</Green>을 사용하는 것입니다. 
텍스처는 2D 이미지 입니다. (1D와 3D 텍스처도 존재합니다) 택스처를 예를 들어 설명하자면
벽돌 이미지가 인쇄된 종이 조각을 3D 집 모형에 잘 감싸 붙여서, 마치 그 집이 실제로 돌로 된 외벽을 가진 것처럼 
보이게 만드는 것입니다. 

단일 이미지 안에 많은 디테일을 담을 수 있기 때문에, 우리는 추가 정점을 만들지 않고도 물체가 매우 정교한
디테일을 가진 것처럼 보이게 할 수 있습니다. 

<Info>
이미지 뿐만 아니라 텍스처는 쉐이더로 전달하기 위한 방대한 양의 임의 데이터(arbitary data)를 저장하는
데에도 사용할 수 있습니다. 하지만 이부분은 다른 주제에서 다루도록 하겠습니다
</Info>

아래에서 전 장의 삼각형에 <LinkBlock url="https://learnopengl.com/img/textures/wall.jpg" text="벽돌 벽"/> 텍스처 이미지가 매핑된걸 볼 수 있습니다.

![textures](./images/getting-started/textures.png)


삼각형에 텍스처를 입히려면 삼각형의 각 정점이 텍스처의 어느 부분에 대응되는지를 알려주어야 합니다. 
따라서 각 정점에는 <Green>텍스처 좌표(Texture Coordinate)</Green>이 함께 있어야 하며, 이 좌표는 텍스처 이미지의 
어떤 부분을 샘플링 할지 지정합니다. 이후 나머지 프래그먼트들은 보간(interpolation)을 통해 자동으로 채워집니다. 


텍스처 좌표는 x축과 y축에서 0에서 1 사이의 값을 사용합니다.(우리는 2D 텍스처 이미지를 사용하고 있다는걸 기억하세요)
텍스처 좌표를 사용해 텍스처 색상을 가져오는 과정을 <Green>샘플링(Sampling)</Green>이라고 부릅니다. 
텍스처 좌표의 시작점은 `(0,0)` 이므로 텍스처 이미지의 왼쪽 아래 모서리를 의미하고, `(1.1)`은 오른쪽 위 모서리를 의미합니다. 

아래 그림은 텍스처 좌표를 삼각형에 매핑하는 방식을 보여줍니다. 

![tex_coords](./images/getting-started/tex_coords.png)

삼각형에 대해 세 개의 텍스처 좌표점을 지정합니다. 삼각형의 왼쪽 아래 부분이 텍스처의 왼쪽 아래 부분에 대응되길 원하므로,
삼각형의 왼쪽 아래 정점에는 `(0.0)` 텍스처 좌표를 사용합니다. 같은 방식으로, 삼각형의 오른쪽 아래 부분은 `(1.0)`텍스처 좌표를 사용합니다.
삼각형의 위쪽 정점은 텍스처 이미지의 위쪽 중앙에 대응되도록 해야하므로 해당 정점에는 `(0.5,1.0)` 텍스처 좌표를 지정합니다. 

우리가 해야할 일은 오직 이 3개의 텍스처 좌표를 정점 쉐이더에 전달하는 것 뿐입니다. 
정점 쉐이더는 이 좌표들을 프래그먼트 쉐이더로 넘기며, 프래그먼트 쉐이더는 모든 프래그먼트에 대해 텍스처 좌표를 깔끔하게 보간(interpolation)해 줍니다. 


<Collapsible title="보간(interpolation) 이란" variant="info">

### 보간 (interpolation)

보간이란 GPU가 삼각형 안쪽의 값들을 자동으로 채워 넣는 과정입니다. 
정점(모서리)에서만 값을 줘도, 그 사이 픽셀(프래그먼트)들의 값을 부드럽게 이어 계산해 줍니다. 텍스터 좌표, 색, 법선 같은
정점 속성들이 보간을 통해 픽샐 단위로 자연스럽게 퍼집니다. 

#### 보간이 일어나는 곳 

- 정점 쉐이더 (Vertex Shader) -> 레스터화 -> 프래그먼트 쉐이더 사이 즉 레스터화 단계에서 일어납니다. 
- 정점 쉐이더가 `out`으로 내보낸 값 (예: `vColor`)은 프래그먼트 쉐이더의 `in`으로 들어가는데 이때 삼각형 내부 위치에 따라 자동 보간 됩니다. 

</Collapsible>

그 결과 텍스처 좌표는 다음과 같이 나타납니다. 

```cpp
float texCoords[] = {
    0.0f, 0.0f,  // lower-left corner  
    1.0f, 0.0f,  // lower-right corner
    0.5f, 1.0f   // top-center corner
};
```

**텍스처 샘플링** 은 해석이 비교적 자유롭고 여러 방식으로 이루어질 수 있습니다. 따라서 OpenGL에 우리가 원하는 **샘플링** 방식을 직접 알려주어야 합니다. 

### Texture Wrapping 텍스처 래핑 
텍스처 좌표는 보통 `(0.0)` 에서 `(1.1)` 사이에 있지만 만약 이 범위를 벗어난 좌표를 지정하면 어떻게 될까요?

OpenGL의 기본 동작은 텍스처 이미지를 반복하는 것입니다.(부동소수점 텍스처 좌표의 정수 부분은 무시됨), 하지만 OpenGL은 그 외에도 
다양한 옵션을 제공합니다. 


<Collapsible title="부동소수점 텍스처 좌표의 정수 부분은 무시됨이란?" variant="info">

텍스처 좌표는 보통 0.0 ~ 1.0 사이에 있어야 합니다. 
만약 그 범위를 벗어난 좌표인 `(1.2,0.3)` , `(2.7,1.5)` 등을 주면 이 범위를 벗어나기 때문에 
OpenGL의 기본 모드에서는 좌표에서 정수 부분은 버리고, 소수 부분만 사용합니다. 
`(1.2,0.3)` -> `(0.2,0.3)` , `(2.7,1.5)` -> `(0.7,0.5)`

</Collapsible>


 - <Blue>GL_REPEAT</Blue> : 텍스처의 기본 동작, 텍스처 이미지를 반복합니다. 
 - <Blue>GL_MIRRORED_REPEAT</Blue> : <Blue>GL_REPEAT</Blue>와 동일하지만, 각 반복마다 이미지를 좌우로 반전시켜서 반복합니다.
 - <Blue>GL_CLAMP_TO_EDGE</Blue>: 좌표를 0과 1 사이로 고정(clamp) 함니다. 결과적으로 범위를 벗어난 좌표는 가장자리에 고정되며,
 텍스처 가장자리가 늘어난 패턴처럼 보입니다. 
 - <Blue>GL_CLAMP_TO_BORDER</Blue>: 범위를 벗어난 좌표에는 사용자가 지정한 경계(border) 색상을 사용합니다. 

 각 옵션은 텍스처 좌표가 기본 범위를 벗어났을 때 서로 다른 시각적 결과를 보여줍니다. 아래 그림은 예제 텍스처 이미지에 
 이러한 옵션들을 적용한 모습입니다. ( 원본 이미지 제공: Hólger Rezende)

![texture_wrapping](./images/getting-started/texture_wrapping.png)

앞서 설명한 각각의 옵션들은 좌표 축 마다 설정할 수 있습니다. 즉 s,t (그리고 3D 텍스처를 사용할 경우 r축) 에 대해 
지정할 수있으며, 이는 각각 x,y,z 좌표에 해당합니다. 이러한 설정은 
 <Func 
  name="glTexParameter"
  description="텍스처 매개변수를 설정합니다. 텍스처 유형, 텍스처 매핑 방식, 필터링 방식 등을 설정할 수 있습니다."
  params='[{"name":"target","type":"GLenum","description":"텍스처 유형을 지정합니다. GL_TEXTURE_2D, GL_TEXTURE_3D 등이 있습니다."},{"name":"pname","type":"GLenum","description":"텍스처 매개변수를 지정합니다. GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T 등이 있습니다."},{"name":"param","type":"GLint","description":"텍스처 매개변수의 값을 지정합니다."}]'
  example="glTexParameter(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);"
  tags='["Textures"]'
/> 함수를 사용하여 설정할 수 있습니다. 

```cpp 

glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_MIRRORED_REPEAT);
glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_MIRRORED_REPEAT);
```

첫 번째 인자는 텍스처 타겟을 지정합니다. 우리는 2D 텍스처를 다루고 있으므로 텍스처 타깃은 <Blue>GL_TEXTURE_2D</Blue>를 사용합니다.
두 번째 인자는 어떤 옵션을 설정할지, 그리고 어떤 텍스처 축에 대해 적용할지를 지정해야 합니다. 여기서는 `S축` 과 `T축` 에 대해 설정합니다.
마지막 인자는 우리가 원하는 텍스처 래핑(Texture Wrapping) 모드를 전달해야 합니다. 위의 코드의 경우 OpenGL은 현재 활성화된 
텍스처의 래핑 옵션을 <Blue>GL_MIRRORED_REPEAT</Blue>로 설정합니다. 

만약 <Blue>GL_CLAMP_TO_BORDER</Blue> 옵션을 사용한다면, 경계 색(border color)도 지정해야 합니다. 
이는  <Func 
  name="glTexParameter"
  description="텍스처 매개변수를 설정합니다. 텍스처 유형, 텍스처 매핑 방식, 필터링 방식 등을 설정할 수 있습니다."
  params='[{"name":"target","type":"GLenum","description":"텍스처 유형을 지정합니다. GL_TEXTURE_2D, GL_TEXTURE_3D 등이 있습니다."},{"name":"pname","type":"GLenum","description":"텍스처 매개변수를 지정합니다. GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T 등이 있습니다."},{"name":"param","type":"GLint","description":"텍스처 매개변수의 값을 지정합니다."}]'
  example="glTexParameter(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);"
  tags='["Textures"]'
/> 함수의 fv 버전에서 <Blue>GL_TEXTURE_BORDER_COLOR</Blue> 매개변수를 사용해 지정할 수 있습니다. 

```cpp 

float borderColor[] = { 1.0f, 1.0f, 0.0f, 1.0f };
glTexParameterfv(GL_TEXTURE_2D, GL_TEXTURE_BORDER_COLOR, borderColor);  
```

## Texture Filtering 텍스처 필터링 

텍스처 좌표는 해상도에 의존하지 않고 임의의 부동소수점 값이 될 수 있습니다.
따라서 OpenGL은 해당 텍스처 좌표를 어떤 텍스처 픽셀 <Green>(텍셀, texel)</Green>에 매핑할지 결정해야 합니다.
이것은 특히 아주 큰 객체에 낮은 해상도의 텍스처를 입히려 할때 중요해 집니다. 
아마 이미 짐작하셨겠지만, OpenGL은 이를 처리하기 위한 <Green>텍스처 필터링(Texture Filtering)</Green> 옵션을 제공합니다. 
다양한 필터링 옵션들이 있지만 우리는 가장 일반적인 두 가지인 <Blue>GL_NEAREST</Blue>와 <Blue>GL_LINEAR</Blue>을 살펴보겠습니다. 

<Blue>GL_NEAREST</Blue>은 (최근접 이웃, <Green>nearest neighbor</Green> 또는 <Green>point filtering</Green> 이라고도 불림) 은 OpenGL의 기본
텍스처 필터링 방식입니다. <Blue>GL_LINEAR</Blue>로 설정하면, OpenGL은 텍스처 좌표와 가장 가까운 중심을 가진 
텍셀(texel)을 선택합니다.  

아래 그림에서 십자가는 정확한 텍스처 좌표를 나타내고, 네 개의 픽셀(텍셀) 이 q보입니다. 
왼쪽 위 텍셀이 가장 텍스처 좌표와 가깝기 때문에 해당 텍셀이 샘플링된 색상으로 선택 됩니다. 

![filter_nearest](./images/getting-started/filter_nearest.png)


<Blue>GL_NEAER</Blue>는 (<Green>선형 보간((bi)linear filtering)</Green> 라고도 함) 텍스처 좌표 주변에 있는 여러 텍셀들의 값을 보간(interpolation) 하여,
그 사이 색상을 근사합니다. 텍스처 좌표가 어떤 텍셀의 중심에 가까울수록, 그 텍셀의 색상이 샘플링된 최종 색에 더 크게 반영됩니다. 

아래 그림에서 보듯이, 주변 픽셀들의 색상이 섞여서 최종적으로 반환되는 색상이 결정됩니다. 

![filter_linear](./images/getting-started/filter_linear.png)

하지만 이러한 텍스처 필터링 방법의 최종 모습은 어떨까요? 
이 방법들이 어떻게 보이는지 해상도가 낮은 이미지를 큰 물체에 매핑해서 알아봅시다(즉 텍스처가 확대되어 개별 텍셀이 눈에 띄는 경우)

![texture_filtering](./images/getting-started/texture_filtering.png)


<Blue>GL_NEAREST</Blue>은 텍스처를 구성하는 픽셀(텍셀)이 또렷하게 보이는 블록 형태의 패턴을 만들어 내고,
<Blue>GL_LINEAR</Blue>는 개별 픽셀이 덜 보이도록 더 매끄러운 패턴을 만듭니다. <Blue>GL_LINEAR</Blue>가 
더 현실적인 결과를 내지만, 일부 개발자는 8비트 게임 같은 느낌을 선호해 <Blue>GL_NEAREST</Blue>를 선택하기도 합니다. 

텍스처 필터링은 <Green>확대(magnify)</Green>와 <Green>축소(minify)</Green> 상황 (즉 스케일을 키우거나 줄일 때)
각각 설정할 수 있습니다. 예를 들어 축소할 때는 최근접(nearest) 필터링을 사용하고, 확대할 때는 선형(linear) 필터링을 사용할 수도 있습니다. 
따라서 두 경우 모두에 대해  <Func 
  name="glTexParameter"
  description="텍스처 매개변수를 설정합니다. 텍스처 유형, 텍스처 매핑 방식, 필터링 방식 등을 설정할 수 있습니다."
  params='[{"name":"target","type":"GLenum","description":"텍스처 유형을 지정합니다. GL_TEXTURE_2D, GL_TEXTURE_3D 등이 있습니다."},{"name":"pname","type":"GLenum","description":"텍스처 매개변수를 지정합니다. GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T 등이 있습니다."},{"name":"param","type":"GLint","description":"텍스처 매개변수의 값을 지정합니다."}]'
  example="glTexParameter(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);"
  tags='["Textures"]'
/>로 필터링 방법을 지정해야 하며, 코드는 래핑 방식 설정과 비슷한 형태가 됩니다. 

```cpp

glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
```


## Minmaps 밉맵

거대한 방 안에 수천개의 물체가 있고 , 각 물체에 텍스처가 붙어 있다고 상상해 봅시다. 
멀리 떨어져 있는 객체들도 가까운 객체와 똑같은 고해상도 텍스처를 사용하게 됩니다. 하지만 
멀리 있는 객체들은 화면상에서 몇 개의 프래그먼트만 차지할 뿐이고, 이 프래그먼트에 올바른 텍스처 색상을 
고해상도 텍스처에서 가져오기는 어렵습니다. 왜냐면 작은 프래그먼트가 사실상 텍스처의 많은 영역을 담아야 하기 때문입니다. 
이로 인해 작은 물체에는 눈에 띄는 아티팩트(artifact)가 발생할 수 있으며, 작은 물체에 고해상도 텍스처를 
적용하는 것은 메모리 대역폭 낭비이기도 합니다. 

이 문제를 해결하기 위해 OpenGL은 <Green>밉맵(mipmaps)</Green>라는 개념을 사용합니다. <Green> 밉맵(mipmaps)</Green>은 
기본적으로 여러장의 텍스처 이미지 집합으로, 각 텍스처는 이전 텍스처의 해상도보다 가로세로가 절반씩 작은 형태입니다. 
밉맵(mipmaps)의 아이디어는 간단합니다. 카메라로부터 일정 거리 이상 떨어진 객체에는, 그 거리에 가장 적합한 
크기의 밉맵(mipmaps) 텍스처를 사용하는 것입니다. 객체가 멀리 떨어져 있으므로 낮은 해상도를 사용해도 
사용자는 차이를 거의 알아차리지 못합니다. 

이렇게 하면 OpenGL은 올바른 텍셀(texel)을 샘플링할 수 있고, 밉맵(mipmaps)의 해당 부분을 샘플링할때 캐시 메모리
사용량도 줄어들게 됩니다. 이제 밉맵(mipmaps)이 적용된 텍스처가 어떻게 보이는지 알아봅시다. 


![mipmaps](./images/getting-started/mipmaps.png)

각 텍스처 이미지마다 밉맵 텍스처 집합을 직접 수동으로 만드는 것은 번거로운 일이지만, 다행이도 OpenGL은 우리가 텍스처를 생성한 뒤 <Func 
  name="glGenerateMipmap" 
  params='[{"name":"target","type":"GLenum","description":"밉맵(mipmaps)을 생성할 텍스처 타겟을 지정합니다. GL_TEXTURE_2D가 일반적입니다."}]'
  description="현재 바인딩된 텍스처에 대해 자동으로 모든 밉맵(mipmaps) 레벨을 생성합니다. 베이스 레벨 이미지에서 시작하여 1x1 픽셀 크기까지 각 레벨을 절반씩 축소하며 생성합니다."
  example="glTexImage2D(GL_TEXTURE_2D, 0, GL_RGB, width, height, 0, GL_RGB, GL_UNSIGNED_BYTE, image);\nglGenerateMipmap(GL_TEXTURE_2D);"
  tags='["Textures"]'
/> 한 줄만 호출하면 이 모든 작업을 자동으로 처리해 줍니다. 


렌더링 중 밉맵 레벨 사이를 전환할 때 OpenGL은 두 밉맵 레이어 사이 경계가 선명하게 보이는 등 
아티팩트(artifacts)가 생길 수 있습니다. 일반 텍스처 필터링 처럼 
밉맵 레벨 사이에서도 <Blue>NEAREST</Blue> 와 <Blue>LINEAR</Blue> 필터링을 사용해 
전환을 부드럽게 만들 수 있습니다. 밉맵 레벨 전환 시의 필터링 방식을 지정하려면 기존 필터링 옵션을 
아래 네 가지 중 하나로 바꾸면 됩니다. 

- <Blue>GL_NEAREST_MIPMAP_NEAREST</Blue> : 픽셀 크기와 가장 비슷한 밉맵을 선택하고 
텍스처 샘플링을 위해 최근접 보간(nearest neighbor interpolation)을 사용합니다.  
- <Blue>GL_LINEAR_MIPMAP_NEAREST</Blue> : 가장 크기가 비슷한 밉맵을 선택하고, 그 밉맵에서 
선형 보간(near interpolation)을 사용합니다.  
- <Blue>GL_NEAREST_MIPMAP_LINEAR</Blue> : 픽셀 크기와 가장 비슷한 두개의 밉맵 레벨 사이에서 
선형 보간을 수행한 뒤 , 보간된 레벨에서 최근접 보간을 사용합니다. 
- <Blue>GL_LINEAR_MIPMAP_LINEAR</Blue> : 픽셀 크기와 가장 비슷한 두 밉맵 레벨 사이에서, 선형 보간을 
수행한 뒤 보간된 레벨에서 선형 보간을 사용합니다. 

일반 텍스처 필터링을 설정하는 것과 동일하게게<Func 
  name="glTexParameter"
  description="텍스처 매개변수를 설정합니다. 텍스처 유형, 텍스처 매핑 방식, 필터링 방식 등을 설정할 수 있습니다."
  params='[{"name":"target","type":"GLenum","description":"텍스처 유형을 지정합니다. GL_TEXTURE_2D, GL_TEXTURE_3D 등이 있습니다."},{"name":"pname","type":"GLenum","description":"텍스처 매개변수를 지정합니다. GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T 등이 있습니다."},{"name":"param","type":"GLint","description":"텍스처 매개변수의 값을 지정합니다."}]'
  example="glTexParameter(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);"
  tags='["Textures"]'
/> 를 통해 위 네 가지 중 하나의 방법을 필터링 옵션으로 지정할 수 있습니다. 

```cpp 
glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR_MIPMAP_LINEAR);
glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
```

일반적인 실수 중 하나는 확대 필터(magnfication filter)에 밉맵 필터링 옵션을 
설정하는 것입니다. 이렇게 해도 효과가 적용되지 않습니다. 왜냐하면 밉맵은 주로 텍스처가 
축소될 때 사용되기 때문입니다. 텍스처 확대에서는 밉맵을 사용하지 않으며, 확대 필터에 밉맵 필터링 옵션을 
지정하면 OpenGL에서 <Blue>GL_INVALID_ENUM</Blue> 오류를 발생시킵니다. 

<Collapsible title="아티팩트(artifact) 이란" variant="info">

### 아티팩트(artifact)란?

컴퓨터 그래픽스에서 아티팩트는 원래 의도하지 않았는데 화면에 생겨버린 이상한 현상이나 깨짐 현상을 의미합니다 
아티팩트 = “기술적 한계나 오류 때문에 생기는 원하지 않는 시각적 결과”

</Collapsible>

## Loading and Creating textures 텍스처를 만들고 가져오기 

텍스처를 실제로 사용하려면 가장 먼저 해야할 일은 이미지를 애플리케이션으로 불러오는 것입니다. 텍스처 이미지는 
수십가지 파일 형식으로 저장될 수 있으며, 각기 다른 데이터 구조와 순서를 가지고 있습니다. 
그렇다면 이런 이미지들을 애플리케이션에 어떻게 가져올 수 있을까요?

하나의 방법은 사용할 파일 형식을 하나 고르고(예:PNG) 그 이미지를 큰 바이트 배열로 변환할 수 있는 
이미지 로더(image loader) 를 직접 작성하는 것입니다. 사실 이미지 로더를 직접 만드는 것은 그렇게 어렵지는 않지만
번거롭습니다. 그리고 더 많은 파일 형식을 지원하게 된다면 어떻게 될까요?그렇게 되면 각 형식마다 이미지 로더를 
따로 작성해야한다는 문제가 있습니다. 

좀 더 나은 방법 (아마 가장 좋은 방법)은 여러 인기 있는 텍스처 포맷을 지원하고 복잡한 작업을 대신 처리해주는 이미지
로딩 라이브러리를 사용하는 것입니다. 대표적인 라이브러리로는 `stb_image.h` 가 있습니다.

### std_image.h 

`std_image.h` 는 <LinkBlock url="https://github.com/nothings" text="Sean Barrett"/>  가 만든 아주 인기 있는 단일 헤더 이미지 
로딩 라이브러리 입니다. 대부분의 유명한 이미지 파일 형식을 불러올 수 있으며, 프로젝트에 통합하기도 쉽습니다. 
`std_image.h`는  <LinkBlock url="https://github.com/nothings/stb/blob/master/stb_image.h" text="여기"/> 에서 다운로드 할 수 있습니다. 
다운로드한 단일 헤더 파일을 프로젝트에 `std_image.h` 라는 이름으로 추가한 뒤 , 별도의 C++ 파일을 만들고 아래 코드를 작성합니다. 

```cpp 

#define STB_IMAGE_IMPLEMENTATION
#include "stb_image.h"
```

