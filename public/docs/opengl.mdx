# OpenGL

여정을 시작하기 전에, OpenGL이 정확히 무엇인지 정의할 필요가 있습니다. OpenGL은 주로 API (Application Programming Interface) 로 여겨집니다. 저희가 그래픽과 이미지를 조작할 수 있도록 해주는 많은 함수를 제공하죠, 
하지만 OpenGL 그 자체는 사실 명세에 가깝습니다. 이는 Khronos Group에 의해 개발되고 유지됩니다. 

OpenGL 명세는 각 함수의 결과/출력이 어떠해야 하는지, 그리고 그 함수가 어떻게 작동해야 하는지를 정확히 정의합니다. 
이후 이 명세를 바탕으로 개발자들은 해당 함수가 어떻게 동작해야 하는지를 직접 구현해야 합니다. OpenGL 명세는 구현 방식에 대한 세부 사항은 제공하지 않기 때문에, 실제 개발된 OpenGL 버전들은 서로 다른 방식으로 구현될 수 있습니다. 
하지만 그 결과는 명세와 일치해야하며 사용자 입장에서 동일한 결과를 제공 받을 수 있어야 합니다.  


<List items={['OpenGL은 그래픽을 그릴 수 있게 해주는 명령어 모음 입니다.', '명세는 이런 명령을 주면 어떤 결과가 나와야 한다고만 적혀 있습니다.', '그 명세를 보고 실제로 프로그램을 만드는건 그래픽 카드 회사 (예, NVIDIA,AMD) 같은 개발자 들입니다.', '그래서 같은 OpenGL 이라도 내부 구현은 다를 수 있지만 결과는 같아야 합니다.']} />

OpenGL 라이브러리를 실제로 개발하는 사람들은 보통 그래픽 카드 제조사들입니다. 당신이 구매하는 그래픽 카드마다 특정 버전의 OpenGL을 지원하는데 이는 해당 그래픽 카드를 위해 특별히 개발된 OpenGL 버전입니다. 

Apple 시스템을 사용할 경우 OpenGL 라이브러리는 Apple이 직접 관리합니다. 반면 리눅스에서는 그래픽 카드 제조사의 버전과 
취미 개발자들이 만든 수정 버전이 혼합되어 존재합니다. 

이 말은 곧, OpenGL이 이상한 동작을 보이거나 버그가 생길 경우, 그 책임은 그래픽 카드 제조사 혹은 해당 라이브러리를 개발하거나 유지보수한 사람에게 있을 가능성이 높다는 뜻입니다. 

<Info>
대부분의 OpenGL 구현체는 그래픽 카드 제조사에서 만들기 때문에, 구현 상의 버그가 있을 경우 비디오 카드 드라이버를 업데이트하면 해결되는 경우가 많습니다.
 이 드라이버 안에는 해당 그래픽 카드가 지원하는 최신 OpenGL 버전이 포함되어 있기 때문입니다. 그래서 그래픽 드라이버를 주기적으로 업데이트하라는 권장 사항은 바로 이런 이유 때문입니다.
</Info>

Khronos 는 모든 OpenGL 버전의 문서를 공개하고 있습니다. 관심이 있으시다면 OpenGL 버전 3.3 문서를 읽는 것을 추천드립니다. (저희가 사용할 OpenGL 버전이기도 합니다.) 이 [문서는](https://registry.khronos.org/OpenGL/specs/gl/glspec33.core.pdf) OpenGL의 작동 원리를 깊이 이해하고 싶은 사람들에게 좋은 참고 자료입니다. (하지만 보통 구현 결과를 설명할뿐 구현 방식은 제공하지 않습니다.) 이러한 명세 문서는 OpenGL 함수들의 정확한 작동 방식을 이해하는 데에도 훌륭한 참고 자료가 됩니다.

![OpenGL](./images/getting-started/opengl.jpg)

## Core-profile vs Immediate mode

과거에는 OpenGL을 사용할 때 주로 **immediate mode**를 사용했습니다. 이는 흔히 **fixed function pipeline**이라고도 불리며, 그래픽을 그리기 위한 간단하고 직관적인 방법이었습니다. 당시에는 대부분의 OpenGL 기능이 라이브러리 내부에 숨겨져 있었기 때문에, 개발자는 OpenGL이 어떻게 계산하는지에 대한 제어권이 거의 없었습니다.

하지만 시간이 지나면서 개발자들은 더 많은 유연성을 원하게 되었고, 이에 따라 OpenGL 명세도 점점 더 유연해졌습니다.
그 결과, 개발자들은 그래픽 렌더링에 대해 더 많은 제어권을 갖게 되었습니다.

즉시 모드는 배우고 사용하기는 매우 쉬웠지만, 성능 면에서는 매우 비효율적이었습니다.
그래서 OpenGL 명세는 **버전 3.2부터 즉시 모드 기능을 점차 폐기**하기 시작했고,
대신 core-profile 모드에서 개발할 것을 권장하게 되었습니다.
이 core-profile 모드는 기존의 오래된 기능들을 제거한 현대적인 OpenGL 모드입니다.


### 🎯 Core-profile 모드의 특징

<List items={['Core-profile을 사용할 경우, OpenGL은 우리에게 현대적인 개발 방식을 강제합니다.', '만약 우리가 이전 버전의 (폐기된) 함수들을 사용하려고 하면, OpenGL은 에러를 발생시키고 렌더링을 중단합니다.', '현대적인 방식은 매우 유연하고 효율적이라는 장점이 있습니다.', '하지만 배우기는 훨씬 더 어렵습니다.']} />


즉시 모드는 OpenGL 내부 동작을 대부분 추상화하여 제공했기 때문에 쉽게 배울 수는 있었지만,
OpenGL이 실제로 어떻게 동작하는지 이해하기는 어려웠습니다.

반면, 현대적인 방식은 개발자가 OpenGL과 그래픽 프로그래밍의 원리를 정말로 이해하도록 요구합니다.
처음에는 어렵지만, 그만큼 **훨씬 더 높은 유연성, 효율성, 그리고 깊이 있는 그래픽 프로그래밍 이해도를 제공합니다.**

### 📘 이 책에서 OpenGL 3.3을 사용하는 이유

이러한 이유로 인해, 이 책은 OpenGL 3.3의  core-profile 모드를 중심으로 설명합니다. 비록 배우기 어렵지만
충분한 가치가 있습니다. 

### ❓ 왜 OpenGL 4.6이 있는데 3.3을 배우나요?

현재 (글 작성 시점 기준) OpenGL 4.6 처럼 더 높은 버전들도 존재합니다. 그러면 왜 **굳이 오래된 3.3버전을 배우느냐**
는 질문이 나올 수 있습니다. 그 이유는 명확합니다. 

<List items={['OpenGL 3.3 이후의 모든 버전은 기본적인 구조나 개념은 바꾸지 않습니다.', '대신, 기존 기능을 조금 더 효율적이고 편리하게 사용할 수 있는 추가 기능만 도입합니다.', '즉, 기본 개념과 기술은 3.3에서도 동일하기 때문에, 3.3을 배우는 것은 여전히 매우 유효합니다.', '나중에 더 경험이 쌓이면, OpenGL 4.x 버전의 추가 기능만 선택적으로 활용하면 됩니다.']} />

<Warning>
가장 최신 버전의 OpenGL 기능을 사용할 경우, 최신 그래픽 카드에서만 해당 애플리케이션이 실행될 수 있습니다. 이러한 이유로 인해 대부분의 개발자들은 일반적으로 낮은 버전의 OpenGL을 기본 타겟으로 삼고, 필요에 따라 더 높은 버전의 기능을 선택적으로 활성화하는 방식을 사용합니다.
</Warning>

일부 챕터에서는 보다 최신의 기능들이 등장하며,
이러한 기능들은 따로 표시되어 있습니다.


## 📌 확장 기능 (Extensions)

OpenGL의 뛰어난 기능 중 하나는 바로 **확장 기능(extension)** 에 대한 지원입니다. 그래픽 카드 회사가 새로운 기술이나 큰 렌더링 최적화를  
성능 최적화 기법을 개발했을 때,이러한 기능은 종종 드라이버에 포함된 확장(extension) 형태로 제공됩니다
어떤 애플리케이션이 실행되는 하드웨어가 해당 확장을 지원한다면, 개발자는 그 확장이 제공하는 고급 기능을 활용해 더 효율적이고
발전된 그래픽 표현을 구현할 수 있습니다. 
이렇게 하면, 그래픽 개발자는 OpenGL의 공식 버전에 기능이 반영되기를 기다릴 필요 없이, 
단순히 그래픽 카드가 해당 확장을 지원하는지 확인만 하면 바로 새로운 기술을 사용할 수 있는 것입니다. 
그리고 종종 인기있고 유용한 확장기능은 차기 OpenGL 공식 버전의 일부로 포함되기도 합니다. 

### 확장 기능 사용 방법

개발자들은 이러한 확장 기능을 사용하기 전에 해당 확장 기능이 사용 가능한지 먼저 확인합니다. 
또는 이를 쉽게 도와주는 OpenGL 라이브러리를 사용할 수 도 있습니다. 
이 과정을 통해 개발자는 해당 확장이 존재하는 경우 그래픽 처리 작업을 더 효율적으로 구현할 수 있습니다. 

```cpp

if(GL_ARB_extension_name)
{
    // 하드웨어가 지원하는 멋진 기능 들 
}
else
{
    // 민액 확장기능이 지원하지 않는다면 옛날 방식으로 
}
```

OpenGL 3.3 버전에서는 우리는 확장 기능을 사용할 일은 거의 없을 것입니다. 하지만 필요하다면 언제든 설명을 제공하겠습니다. 


## State machine 

OpenGL은 그 자체로 거대한 상태 머신 입니다. 
즉 OpenGL이 어떻게 동작해야 하는지를 정의하는 변수들의 집합이라고 볼 수 있습니다.
이러한 OpenGL의 상태는 일반적으로 OpenGL 컨텍스트 라고 불립니다. 
OpenGL을 사용할때 우리는 자주 상태를 변경하게 됩니다. 
옵션을 설정하고, 버퍼를 수정하고, 현재 상태를 바탕으로 렌더링을 수행하게 됩니다. 
우리가 OpenGL에게 삼각형 대신 선을 그리고 집다고 말할 때마다, 우리는 OpenGL의 상태를 컨텍스트(context)를 
변경하여 바꾸게 됩니다. 그리고 이후의 그리기 명령들은 자동으로 선 그리기 방식을 따르게 됩니다.
OpenGL을 다루다 보면, 다음과 같은 두 종류의 함수들을 자주 만나게 됩니다:

<List items={['상태를 바꾸는 함수(state-changing functions)→ OpenGL의 컨텍스트를 변경합니다.', '상태를 사용하는 함수(state-using functions)→ 현재 설정된 상태를 기반으로 어떤 동작을 수행합니다.']} />

OpenGL을 이해하는 데 있어 중요한 핵심은:

<Warning>
OpenGL은 하나의 거대한 상태 머신이다
</Warning>

이 개념을 기억하고 있다면, OpenGL의 동작 방식이 훨씬 잘 이해될 것입니다.

## 객체 

OpenGL 라이브러리는 C언어로 작성되었으며, 다양한 다은 언어에서도 사용할 수 있지만, 핵심적으로는 C 기반의 라이브러리 입니다. 

그러나 C언어의 문법 구조는 다른 고급 언어와 완벽하게 호환되지 않는 경우가 많기 때문에 OpenGL은 이러한 점을 고려해 
몇가지 추상화 개념(abstractions)를 도입했습니다. 

그중 하나가 바로 **OpenGL 객체** 입니다. 

### OpenGL 에서의 객체란

OpenGL에서 객체란 OpenGL 상태의 일부분을 대표하는 설정값들의 집합입니다. 
예를 들어, 하나의 객체는 그리기 창(window)의 설정을 나타낼 수 있으며 
이 객체에는 창의 크기, 색상 수, 이름 등 다양한 옵셕ㄴ을 설정할 수 있습니다. 
이를 c언어 스타일로 표현하면 다음과 같습니다. 

```c

struct object_name {
    float  option1;
    int    option2;
    char[] name;
};

```

우리가 객체를 사용할 때마다 보통 이렇게 보입니다. ( OpenGL 컨텍스트가 하나의 구조체로 표현됩니다.)

```c

// OpenGL 전체 상태
struct OpenGL_Context {
    ...
    object_name* object_Window_Target;
    ...
};

```

객체 사용 순서 예시

```c
unsigned int objectId = 0;

// 1. 객체 생성
glGenObject(1, &objectId);

// 2. 생성한 객체를 컨텍스트의 특정 타겟(GL_WINDOW_TARGET)에 바인딩
glBindObject(GL_WINDOW_TARGET, objectId);

// 3. 해당 객체에 다양한 옵션 설정
glSetObjectOption(GL_WINDOW_TARGET, GL_OPTION_WINDOW_WIDTH,  800);
glSetObjectOption(GL_WINDOW_TARGET, GL_OPTION_WINDOW_HEIGHT, 600);

// 4. 객체 언바인딩 (초기화)
glBindObject(GL_WINDOW_TARGET, 0);

```

glGenObject는 객체를 생성하고 그에 대한 ID를 반환합니다. glBindObject는 해당 객체를 현재 OpenGL 컨텍스트의 타겟 위치 <span style={{color: 'blue'}}>GL_WINDOW_TARGET</span>에 바인딩합니다. 그 다음, glSetObjectOption으로 객체의 세부 옵션을 설정합니다. glBindObject(..., 0)을 사용하면 해당 타겟에서 객체를 해제(언바인딩)합니다.

이 모든 옵션은 <span style={{color: 'blue'}}>objectId</span> 연결된 실제 객체 내부에 저장되고, 다시 <span style={{color: 'blue'}}> GL_WINDOW_TARGET</span>에 바인딩하면 그대로 복원됩니다.

이 흐름은 OpenGL 작업에서 반복적으로 자주 쓰이는 패턴입니다.

### 객체의 장점 

OpenGL에서 객체를 사용하면 여러 개의 객체를 만들어 따로따로 설정할 수 있고,
작업 시점에 맞춰 원하는 객체를 필요할 때마다 바인딩하여 사용할 수 있습니다.

예를 들어: 3D 모델 객체를 각각 하나의 OpenGL 객체로 만들 수 있습니다. (예: 집, 캐릭터 등) 미리 설정해 둔 각 객체를 그릴 때마다 바인딩만 하면 되고,
다시 설정을 반복하지 않아도 됩니다.

이제 시작해봅시다! 지금까지 우리는 다음 내용을 배웠습니다:

<List items={['OpenGL이 명세(Specification)이자 라이브러리(Library)라는 점', '내부에서 어떻게 동작하는지에 대한 개략적인 흐름', 'OpenGL만의 독특한 트릭, 예: 상태 머신 구조, 객체 시스템 등']} />

처음에는 모든 개념이 완벽히 이해되지 않아도 괜찮습니다.
이 책에서는 앞으로 하나하나 자세히 다루며 풍부한 예제를 통해 OpenGL을 완전히 익히도록 도와줄 것입니다.

## 추가 자료 

<LinkBlock url="https://www.opengl.org/" text="opengl.org"/>  OpenGL 공식 웹사이트

<LinkBlock url="https://registry.khronos.org/OpenGL/index_gl.php" text="opengl registry"/>  모든 OpenGL 버전의 명세와 확장 기능 문서를 제공
