# Shaders 쉐이더 

<LinkBlock url="https://learnopenglkr.com/#hellotriangle" text="Hello Triangle"/> 챕터에서 
언급했듯이, 쉐이더는 GPU에 위치하는 작은 프로그램들 입니다. 이 프로그램들은 
그래픽스 파이프라인(Graphics Pipeline)의 각각의 특정 영역에서 돌아갑니다. 
기본적으로 쉐이더는 입력값(inputs)을 출력값(outputs)으로 바꾸는 것 그 이상도 이하도 아닙니다. 
쉐이더들은 또한 독립적인 프로그램입니다. 그 말은 서로 소통할 수 없다는 의미입니다. 
그들이 서로 소통할 수 있는 유일한 방법은 그들의 입력값과 출력값 뿐입니다. 

이전 장에서 우리는 쉐이더에 대해 겉햝기를 했습니다. 그리고 어떻게 그들을 적절히 사용할 수 있는지 배웠죠
이제는 쉐이더에 대해 더 설명할 차례입니다. 정확히는 OpenGL 쉐이딩 언어(OpenGL Shading Languaue)에 대해 말이죠 

# GLSL 

쉐이더들은 C 언어와 같은 언어인 GLSL로 작성됩니다. GLSL은 그래픽스 사용에 맞게 설계되었으며, 벡터와 행렬
연산에 특화된 유용한 기능들을 포함하고 있습니다. 

쉐이더는 항상 버전 선언으로 시작하며, 그 뒤에 입력 변수(input), 출력 변수(output), uniform,그리고 `main` 함수가
옵니다. 각 쉐이더의 진입점(entry point)는 `main` 함수이며, 여기서 입력 변수를 처리하고 결과를 
출력 변수에 기록합니다. 

`uniform`이 무엇인지 몰라도 괜찮습니다. 곧 다루게 될 것입니다. 

쉐이더는 보통 다음과 같은 형태를 가집니다. 

```cpp
#version version_number
in type in_variable_name;
in type in_variable_name;

out type out_variable_name;
  
uniform type uniform_name;
  
void main()
{
  // process input(s) and do some weird graphics stuff
  ...
  // output processed stuff to output variable
  out_variable_name = weird_stuff_we_processed;
}
```

우리가 정점 쉐이더 (vertex shader)에 대해 알아보았을때 각각의 입력 변수들은 <Green> 정점 속성 (vertex attribute) </Green>
라고도 알려진다고 했습니다. 
우리가선언할 수 있는 정점 속성의 최대 개수는 하드웨어에 의해 제한됩니다. 
OpenGL은 최소한 16개의 4-컴포넌트 정점 속성을 항상 사용할 수 있도록 보장하지만, 일부 하드웨어에서는 더
많은 정점 속성을 지원할 수도 있습니다. 이 경우 <Blue>GL_MAX_VERTEX_ATTRIBS</Blue>를 통해 
확인할 수 있습니다. 


<TranslatorNote type="clarification" author="이도경" collapsible={true} defaultOpen={false}>
### 정점 속성(Vertex Attribute)란?
정점 하나가 가진 데이터 조각 

정점(vertex) = 3D 공간의 한 점 
하지만 점 하나가 단순히 (x,y,z) 좌표만 있는 것이 아니라 보통 여러 정보를 가진다 (예: 위치 , 색상,법선 벡터, 텍스터 좌표)
이 각각이 정점 속성이다. 

사각형을 그린다고 하면 각 정점에는 이런 데이터가 있을 수 있다. 
```makefile
위치: (0.5, 0.5, 0.0)
색상: (1.0, 0.0, 0.0)   → 빨강
UV:   (1.0, 1.0)
```

여기서 
- 위치 = 정점 속성 #0
- 색상 = 정점 속성 #1 
- UV - 정점 속성 #2 

쉐이더에서는 이렇게 받게 된다. 

```GLSL
layout (location = 0) in vec3 aPos;    // 위치
layout (location = 1) in vec3 aColor;  // 색상
layout (location = 2) in vec2 aTex;    // 텍스처 좌표
```

- 따라서 4-컴포넌트 정점 속성이란, 각 속성은 `vec4`처럼 최대 4개의 값(X,y,z,w)를 가질 수 있다. 
- 16개의 4-컴포넌트 보장이란? : 최소한 16개의 속성 슬롯을 항상 쓸 수 있다. 즉 `vec4` 기준으로 16개 -> float 4 X 16 = 64개의 float 값을 정점당 전달 가능  

</TranslatorNote> 



```cpp

int nrAttributes;
glGetIntegerv(GL_MAX_VERTEX_ATTRIBS, &nrAttributes);
std::cout << "Maximum nr of vertex attributes supported: " << nrAttributes << std::endl;
```
이는 보통 최소 16을 반환합니다. 그리고 16개로 충분히 대부분의 목적을 소화할 수 있습니다. 

## Types 

GLSL은 다른 프로그래밍 언어와 마찬가지로 작업하고자 하는 변수의 종류를 지정하기 위한 데이터 타입을 가지고 있습니다. 
GLSL은 C와 같은 언어에서 알고 있는 대부분의 기본 타입들을 가지고 있습니다: `int`, `float`, `double`, `uint`, `bool`. GLSL은 또한 우리가 많이 사용할 두 가지 컨테이너 타입인 벡터(vectors)와 행렬(matrices)을 제공합니다. 행렬은 나중 장에서 다루겠습니다.

### 벡터 (Vectors)

GLSL에서 벡터는 앞서 언급한 기본 타입들 중 하나에 대한 2, 3 또는 4개 구성요소 컨테이너입니다. 다음과 같은 형태를 가질 수 있습니다 (n은 구성요소의 수를 나타냅니다):

- `vecn`: n개의 float로 구성된 기본 벡터
- `bvecn`: n개의 boolean으로 구성된 벡터  
- `ivecn`: n개의 integer로 구성된 벡터
- `uvecn`: n개의 unsigned integer로 구성된 벡터
- `dvecn`: n개의 double 구성요소로 구성된 벡터

대부분의 경우 float가 우리 목적에 충분하므로 기본 `vecn`을 사용할 것입니다.

벡터의 구성요소는 `vec.x`를 통해 접근할 수 있습니다. 여기서 x는 벡터의 첫 번째 구성요소입니다. `.x`, `.y`, `.z`, `.w`를 사용하여 각각 첫 번째, 두 번째, 세 번째, 네 번째 구성요소에 접근할 수 있습니다. GLSL은 또한 색상에 대해서는 `rgba`를, 텍스처 좌표에 대해서는 `stpq`를 사용하여 동일한 구성요소에 접근할 수 있도록 합니다.

벡터 데이터 타입은 **스위즐링(swizzling)**이라고 불리는 흥미롭고 유연한 구성요소 선택을 허용합니다. 스위즐링을 사용하면 다음과 같은 문법을 사용할 수 있습니다:

```glsl
vec2 someVec;
vec4 differentVec = someVec.xyxx;
vec3 anotherVec = differentVec.zyw;
vec4 otherVec = someVec.xxxx + anotherVec.yxzy;
```
원래 벡터가 해당 컴포넌트를 가지고 있기만 하다면 최대 4개의 글자를 조합해 새로운 벡터(같은 타입)를 만들 수 있습니다. 하지만 예를 들어 `vec2`에서는 `.z` 컴포넌트에 접근하는 것은 
허용되지 않습니다. 또한 벡터를 다른 벡터 생성자의 인자로 전달할 수도 있는데, 이렇게 하면 필요한 인자 수를 줄일 수 있습니다. 


```cpp 

vec2 vect = vec2(0.5, 0.7);
vec4 result = vec4(vect, 0.0, 0.0);
vec4 otherResult = vec4(result.xyz, 1.0);
```

벡터들은 그렇기에 유연한 데이터 타입입니다. 이들을 통해 온갖 입력값과 출력값을 만들 수 있습니다. 
이 책 내에서 우리는 벡터를 다룰 여러가지 창의적인 예시를 보게 될 것입니다. 

### Ins and outs 

쉐이더는 그 자체로 작은 프로그램이지만, 전체 그리픽 파이프라인의 일부이기도 합니다. 그래서 쉐이더 마다 
입력과 출력을 정의하여 서로 데이터를 주고 받을 수 있도록 해야합니다. GLSL은 이를 위해  `in` 와 `out` 키워드를 제공합니다. 
각 쉐이더는 이 키워드를 통해 입력과 출력을 정의할 수 있으며, 한 쉐이더의 출력 변수가 다음 쉐이더의 입력 변수와 일치하면 값이 전달 됩니다. 
다만, 정점 쉐이더와 프래그먼트 쉐이더는 이 부분에서 약간 차이가 있습니다. 

정점 쉐이더는 **반드시** 어떤 형태의 입력을 받아야 합니다. 그렇지 않으면 사실상 비활성화 되어있기 때문입니다. 정점 쉐이더의 입력은 특별한데
바로 정점 데이터(vertex data)에서 직접 값을 받습니다. 정점 데이터가 어떻게 구성되어 있는지 정의하기 위해 
우리는 입력 변수에 location 메타 데이터를 지정하여 CPU에서 정점 속성을 설정할 수 있도록 합니다. 
지난 장에서 본 `layout(location=0)`이 바로 그것입니다. 
따라서 정점 쉐이더의 입력은 정점 데이터와 연결될 수 있도록 추가적인 `layout` 지정이 필요합니다. 

<Info>
물론 `layout (location = 0)` 지정자를 생략하고 OpenGL 코드에서 <Func 
  name="glGetAttribLocation"
  description="glGetAttribLocation 함수는 링킹 단계에서 할당된 정점 속성 위치를 주어진 쉐이더 프로그램과 속성 이름을 통해 조회합니다. 위치를 찾을 수 없으면 -1을 반환합니다. 이는 속성 이름이 잘못되었거나, 정점 속성이 실제로 쉐이더 코드에서 사용되지 않아 컴파일러에 의해 삭제/최적화되었기 때문일 수 있습니다."
  params='[{"name":"program","type":"GLuint","description":"쿼리할 프로그램 객체를 지정합니다."},{"name":"name","type":"const GLchar*","description":"위치를 쿼리할 정점 속성의 이름을 포함하는 null로 끝나는 문자열에 대한 포인터입니다."}]'
  example={`GLint vertAttribLoc;
vertAttribLoc = glGetAttribLocation(shaderProgram, "position");
glEnableVertexAttribArray(vertAttribLoc);`}
  tags={[
    "Shaders"
  ]}
/>을 통해 속성 위치를 쿼리할 수도 있지만, 
정점 쉐이더에서 직접 설정하는 것이 더 쉽고 이해하기 쉬우며 여러분(그리고 OpenGL)의 작업을 줄여줍니다.
</Info>


또 다른 예외는 프래그먼트 쉐이더 (Fragment Shader)인데 이 쉐이더는 최종 출력 색상을 만들어 내야 하기 때문에 
`vec4` 타입의 색상 출력 변수가 필요합니다. 만약 프래그먼트 쉐이더에서 출력 색상을 지정하지 않으면
해당 프래그먼트의 컬러 버퍼 출력은 정의되지 않은 상태가 됩니다. ( 보통 OpenGL은 그것을 검정색이나 흰색으로 렌더링 합니다)

따라서 한 쉐이더에서 다른 쉐이더로 데이터를 전달하려면 보내는 쉐이더에서는 출력 변수를 선언하고, 받는 쉐이더에서는 동일한 입력 변수를 
선언해야 합니다. 양쪽의 타입과 이름이 같다면, OpenGL은 이 변수들을 서로 연결해주고 쉐이더 간에 데이터를 주고 받을 수 있게 됩니다. 
(이 연결은 프로그램 객체를 링크할 때 이루어 집니다.)

이 방식이 실제로 어떻게 동작하는지 보여주기 위해, 이전 장의 쉐이더를 수정해서 정점 쉐이더가 프래그먼트 쉐이더의 색상을 결정하도록 
만들어 보겠습니다. 

##### Vertex Shader ( 정점 쉐이더 )

```glsl
#version 330 core
layout (location = 0) in vec3 aPos; // the position variable has attribute position 0
  
out vec4 vertexColor; // specify a color output to the fragment shader

void main()
{
    gl_Position = vec4(aPos, 1.0); // see how we directly give a vec3 to vec4's constructor
    vertexColor = vec4(0.5, 0.0, 0.0, 1.0); // set the output variable to a dark-red color
}
```


 ##### Fragment Shdaer (프래그먼트 쉐이더)


 ```glsl 
 
#version 330 core
out vec4 FragColor;
  
in vec4 vertexColor; // the input variable from the vertex shader (same name and same type)  

void main()
{
    FragColor = vertexColor;
} 
``` 
보시다시피 우리는 정점 쉐이더에서 <Blue>vec4</Blue> 타입의 출력 변수인 <Blue>vertexColor</Blue>를 선언하고 
값을 설정했습니다. 그리고 프래그먼트 쉐이더에서는 동일한 이름의 입력 변수 <Blue>vertexColor</Blue>를 선언했습니다. 
두 변수는 타입과 이름이 같기 때문에 프래그먼트 쉐이더의 <Blue>vertexColor</Blue>는 정점 쉐이더의 <Blue>vertexColor</Blue>와 자동으로 연결됩니다. 

정점 쉐이더에서 색상을 어두운 빨강으로 설정했으므로 최종적으로 생성되는 프래그먼트들도 어두운 빨강색으로 나타나야합니다. 아래 이미지는 
그 출력 결과를 보여줍니다. 


![shaders](./images/getting-started/shaders.png)

보이시나요! 우리는 방금 정점 쉐이더에서 프래그먼트 쉐이더로 값을 전달하는데 성공했습니다. 
이제 좀더 조미료를 쳐서 애플리케이션에서 프래그먼트 쉐이더로 색상을 전달할수 있는지도 확인해 보죠

### Uniforms 
<Green>Uniform</Green>은 CPU에 있는 애플리케이션에서 GPU의 쉐이더로 데이터를 전달하는 또 다른 방법 입니다. 
하지만 uniform은 정점 속성과는 약간 다릅니다. 

<NumberedList>
    <NumberedItem> Uniform은 <Green>전역(global)</Green> 입니다. 전역 이라는 뜻은, uniform 변수는 쉐이더 프로그램 객체마다 고유하며, 쉐이더 프로그램의 
    어떤 단계든 접근할 수 있다는 의미입니다 </NumberedItem>
    <NumberedItem> uniform은 한번 값을 설정하면 그 값은 리셋되거나 업데이트 될 때 까지 유지됩니다. </NumberedItem>
</NumberedList>

GLSL에서 <Blue>uniform</Blue>를 선언하려면 단순히 uniform 키워드와 함께 타입, 이름을 쉐이더에 추가하면 됩니다. 그 시점부터 쉐이더 안에서 새로 선언한 
uniform을 사용할 수 있습니다. 

이제 이번에는 uniform을 이용해서 삼각형의 색상을 지정할 수 있는지 확인해 봅시다. 

```glsl 
#version 330 core
out vec4 FragColor;
  
uniform vec4 ourColor; // we set this variable in the OpenGL code.

void main()
{
    FragColor = ourColor;
}   
```

우리는 프래그먼트 쉐이더에 <Blue>uniform vec4 outColor </Blue>를 선언했고, 프래그먼트의 출력 색상을 이 uniform의 값으로 설정했습니다. 
Uniform은 전역 변수이기 때문에 원하는 어떤 쉐이더 단계에서든 정의할 수 있스며, 프래그먼트 쉐이더로 무언가를 전달하기 위해 굳이 
정점 쉐이더를 거칠 필요가 없습니다. 우리는 이 uniform을 정점 쉐이더에서는 사용하지 않으므로 정점 쉐이더에 따로 정의할 필요도 없습니다. 


<Warning>
만약 GLSL 코드에서 어디에서도 사용하지 않는 uniform을 선언하면 컴파일러는 그 변수를 조용히 제거해 버립니다. 이것 때문에 꽤 골치아픈 오류가 발생하기도 하니 꼭 기억해두세요! 
</Warning>

현재 uniform은 비어있습니다. 아직 이 uniform에 값을 추가하지 않았기 때문입니다. 
이제 uniform에 값을 넣어 보겠습니다. 우선 쉐이더 안에서 uniform 속성의 인덱스/위치를 찾아야 합니다. 
그 위치를 찾은 다음에야 uniform 값을 업데이트 할 수 있습니다. 

단순히 하나의 색상을 프래그먼트 쉐이더에 전달하는 대신, 이번에는 좀더 흥미롭게 시간에 따라 색이 점점 변하도록 만들어 봅시다. 

```cpp
float timeValue = glfwGetTime();
float greenValue = (sin(timeValue) / 2.0f) + 0.5f;
int vertexColorLocation = glGetUniformLocation(shaderProgram, "ourColor");
glUseProgram(shaderProgram);
glUniform4f(vertexColorLocation, 0.0f, greenValue, 0.0f, 1.0f);
```

우선 우리는 <Func name="glfwGetTime" params='[]' description="GLFW가 초기화된 이후 경과된 시간을 초 단위로 반환합니다." tags={["GLFW"]} />을 사용해 실행 시간을 초 단위로 가져옵니다. 그런다음 <Red>sin</Red> 함수를 사용해 색상을 0.0 ~ 1.0 범위에서 변화시키고 
그 결과를 <Blue>greenValue</Blue>에 저장합니다. 그 다음 <Func name="glGetUniformLocation" params='[{"name":"program","type":"GLuint","description":"uniform 변수를 포함하는 프로그램 객체"},{"name":"name","type":"const GLchar*","description":"uniform 변수의 이름"}]' description="지정된 프로그램에서 uniform 변수의 위치를 조회합니다. uniform이 존재하지 않거나 사용되지 않으면 -1을 반환합니다." tags={["Shaders"]} />
을 사용해서 uniform <Blue>ourColor</Blue>의 위치를 조회합니다.
이 조회 함수에는 쉐이더 프로그램과 위치를 알고싶은 uniform의 이름을 전달합니다. 만약 <Func name="glGetUniformLocation" params='[{"name":"program","type":"GLuint","description":"uniform 변수를 포함하는 프로그램 객체"},{"name":"name","type":"const GLchar*","description":"uniform 변수의 이름"}]' description="지정된 프로그램에서 uniform 변수의 위치를 조회합니다. uniform이 존재하지 않거나 사용되지 않으면 -1을 반환합니다." tags={["Shaders"]} />이 `-1`을 반환한다면, 
해당 uniform의 위치를 찾을 수 없다는 뜻입니다.

마지막으로 <Func name="glUniform" params='[{"name":"location","type":"GLint","description":"수정할 uniform 변수의 위치"},{"name":"count","type":"GLsizei","description":"벡터 타입인 경우 요소의 개수"},{"name":"value","type":"다양한 타입","description":"벡터 명령의 경우, 업데이트할 지정된 uniform 변수에 사용될 count 값들의 배열에 대한 포인터"}]' description="glUniform 함수는 현재 활성화된 쉐이더 프로그램의 uniform 값을 설정합니다. uniform 위치는 제공되어야 하며 이는 glGetUniformLocation을 사용해서 조회할 수 있습니다. 이 함수는 여러 오버로드된 타입을 가지고 있으며 올바른 타입의 함수를 적절한 접미사(예: i, 3ui, fv 등)로 호출해야 합니다." tags={["Shaders"]} />
 함수를 이용용해 uniform 값을 설정할 수 있습니다. 주의할 점은 uniform 위치를 찾을 때는 쉐이더 프로그램을 먼저 활성화 할 필요가 없지만, uniform 값을 업데이트 할 때는 반드시 <Func 
  name="glUseProgram"
  params='[{"name":"program","type":"GLuint","description":"사용할 쉐이더 프로그램 객체를 지정합니다. 이 프로그램 객체는 컴파일되고 링크되어야 합니다."}]'
  description="주어진 프로그램 객체를 현재 활성 쉐이더 프로그램으로 설정하여 후속 그리기 명령에 사용합니다. 0 값이 제공되면 OpenGL은 이전 그리기 패턴으로 되돌아갑니다."
  example="glUseProgram(shaderProgram); glBindVertexArray(VAO); glDrawElements(GL_TRIANGLES, 6, GL_UNSIGNED_INT, 0); glBindVertexArray(0);"
  tags='["Shaders", "Program Usage"]'
/> 을 호출해 프로그램을 활성화 해야 한다는 것입니다. 왜냐면 uniform 값은 현재 활성화 된 쉐이더 프로그램에 적용되기 때문입니다.



<Info> 
OpenGL은 근본적으로 C라이브러리이기 때문에, 함수 오버로딩을 네이티브로 지원하지 않습니다. 따라서 하나의 함수가 여러 타입으로 호출될 수 있는 경우,
OpenGL은 필요한 타입마다 새로운 함수를 정의합니다. <Func name="glUniform" params='[{"name":"location","type":"GLint","description":"수정할 uniform 변수의 위치"},{"name":"count","type":"GLsizei","description":"벡터 타입인 경우 요소의 개수"},{"name":"value","type":"다양한 타입","description":"벡터 명령의 경우, 업데이트할 지정된 uniform 변수에 사용될 count 값들의 배열에 대한 포인터"}]' description="glUniform 함수는 현재 활성화된 쉐이더 프로그램의 uniform 값을 설정합니다. uniform 위치는 제공되어야 하며 이는 glGetUniformLocation을 사용해서 조회할 수 있습니다. 이 함수는 여러 오버로드된 타입을 가지고 있으며 올바른 타입의 함수를 적절한 접미사(예: i, 3ui, fv 등)로 호출해야 합니다." tags={["Shaders"]} />
이 그 예시입니다. 

이 함수는 설정하려는 uniform의 타입에 따라 특정 접미사(postfix)를 요구합니다. 몇가지 예시는 다읍과 같습니다. 

- `f`: `float` 값을 기대함
- `i`: `int` 값을 기대함
- `ui`: `unsigned int` 값을 기대함
- `3f`: `float` 값 3개를 기대함
- `fv`: `float` 벡터/배열을 기대함

OpenGL 옵션을 설정할때는 단순히 자신의 타입에 맞는 함수 버전을 선택하면 됩니다. 
우리의 경우 uniform에 4개의 float 값을 각각 전달하려고 하므로 <Red>glUniform4f</Red>를 사용합니다.(참고로 `fv` 버전을 사용할 수도 있습니다.)

</Info> 

이제 uniform 변수의 값을 설정하는 법을 알았으니, 이를 렌더링에 사용할 수 있습니다. 
색상이 점차 변하도록 만들고 싶다면, uniform 값을 매 프레임마다 업데이트 해야합니다. 만약 한 번만 설정한다면 삼각형은 단일 색상으로만 유지될 것입니다. 
따라서 매 렌더링 반복(iteration) 마다 <Blue>greenValue</Blue>를 계산하고 그 값을 uniform에 업데이트 해야합니다. 

```cpp 
while(!glfwWindowShouldClose(window))
{
    // input
    processInput(window);

    // render
    // clear the colorbuffer
    glClearColor(0.2f, 0.3f, 0.3f, 1.0f);
    glClear(GL_COLOR_BUFFER_BIT);

    // be sure to activate the shader
    glUseProgram(shaderProgram);
  
    // update the uniform color
    float timeValue = glfwGetTime();
    float greenValue = sin(timeValue) / 2.0f + 0.5f;
    int vertexColorLocation = glGetUniformLocation(shaderProgram, "ourColor");
    glUniform4f(vertexColorLocation, 0.0f, greenValue, 0.0f, 1.0f);

    // now render the triangle
    glBindVertexArray(VAO);
    glDrawArrays(GL_TRIANGLES, 0, 3);
  
    // swap buffers and poll IO events
    glfwSwapBuffers(window);
    glfwPollEvents();
}
```

이 코드는 이전 코드에서 비교적 간단히 수정된 버전입니다. 이번에는 삼각형을 그리기 전에 매 프레임마다 uniform 값을 업데이트 해야합니다. 
만약 uniform을 올바르게 업데이트 했다면, 삼각형의 색상이 초록색에서 검은색으로 점차 변했다가 다시 초록색으로 돌아오는 모습을 볼 수 있을 것입니다. 

<VideoPlayer 
  src="/images/getting-started/shaders.mp4"
  title="쉐이더 예제 - 색상 변화"
  description="uniform 변수를 사용해서 시간에 따라 색상이 변하는 삼각형을 구현하는 예제의 결과 입니다다."
/> 

만약 막혔다면 <LinkBlock url="https://learnopengl.com/code_viewer_gh.php?code=src/1.getting_started/3.1.shaders_uniform/shaders_uniform.cpp" text="여기"/> 에서 소스코드를 확인해 보세요 

보시다시피,uniform은 매 프레임마다 바뀔 수 있는 속성을 설정하거나, 애플리케이션과 쉐이더 간에 데이터를 주고 받는데 유용한 도구 입니다. 하지만 만약 
각 정점마다 다른 색상을 설정하고 싶다면 어떻게 될까요? 그 경우 정점의 개수 만큼 uniform을 선언해야 할 것입니다. 

더 나은 해결책은 정점 속성(vertex Attribute)에 더 많은 데이터를 포함시키는 것입니다. 이제 우리가 하려는 것이 바로 그것입니다. 


## More attributes! 더 많은 속성들! 

우리는 지난 장에서 VBO를 채우고 , 정점 속성 포인터를 설정하며, 그것을 VAO에 저장하는 방법을 살펴봤습니다. 이번에는 여기에 색상 데이터도 정점 데이터(VBO) 에 추가하고자 합니다. 
정점 배열에 색상 데이터를 float 3개(RGB)로 추가할 것입니다. 그리고 삼각형의 각 꼭짓점에 각각 빨강,초록,파랑 색을 할당하겠습니다. 

```cpp 
float vertices[] = {
    // positions         // colors
     0.5f, -0.5f, 0.0f,  1.0f, 0.0f, 0.0f,   // bottom right
    -0.5f, -0.5f, 0.0f,  0.0f, 1.0f, 0.0f,   // bottom left
     0.0f,  0.5f, 0.0f,  0.0f, 0.0f, 1.0f    // top 
};   
```
이제 정점 쉐이더 (vertex shader)에 보낼 데이터가 많아졌으니, 정점 쉐이더가 색상 값도 정점 속성(vertex attribute) 입력값으로 받도록 하는것이 필요합니다. 
이때는 `aColor` 라는 속성의 `location`을 `1`로 설정한 다는 것을 명심하세요 

```glsl 
#version 330 core
layout (location = 0) in vec3 aPos;   // the position variable has attribute position 0
layout (location = 1) in vec3 aColor; // the color variable has attribute position 1
  
out vec3 ourColor; // output a color to the fragment shader

void main()
{
    gl_Position = vec4(aPos, 1.0);
    ourColor = aColor; // set ourColor to the input color we got from the vertex data
}       

``` 

이제 우리는 프래그먼트 색상을 uniform으로 설정하지 않고, <Blue>ourColor</Blue> 출력 변수를 사용하므로 프래그먼트 쉐이더도 이에 맞추어 수정해야합니다. 

```cpp 
#version 330 core
out vec4 FragColor;  
in vec3 ourColor;
  
void main()
{
    FragColor = vec4(ourColor, 1.0);
}
```
우리는 새로운 정점 속성을 추가했고 VBO의 메모리를 업데이트 했기 때문에 정점 속성 포인터(vertex attribute pointers)를 다시 설정해야합니다. 
VBO메모리에 업데이트된 데이터는 이제 다음과 같은 형태를 띄게 됩니다. 

![vertex_attribute_pointer_interleaved](./images/getting-started/vertex_attribute_pointer_interleaved.png)


현재의 레이아웃을 바탕으로 우리는 정점 형식을을 <Func 
  name="glVertexAttribPointer"
  params='[{"name":"index","type":"GLuint","description":"정점 속성의 인덱스를 지정합니다."},{"name":"size","type":"GLint","description":"정점 속성당 구성 요소의 수를 지정합니다. 1, 2, 3, 4 중 하나여야 합니다."},{"name":"type","type":"GLenum","description":"배열의 각 구성 요소의 데이터 타입을 지정합니다. GL_BYTE, GL_UNSIGNED_BYTE, GL_SHORT, GL_UNSIGNED_SHORT, GL_INT, GL_UNSIGNED_INT, GL_FLOAT, GL_DOUBLE 등이 있습니다."},{"name":"normalized","type":"GLboolean","description":"데이터가 정규화되어야 하는지 지정합니다. 정수 값의 경우 0에서 1 범위(부호 없는 값) 또는 -1에서 1 범위(부호 있는 값)로 매핑됩니다."},{"name":"stride","type":"GLsizei","description":"연속된 정점 속성 사이의 바이트 오프셋을 지정합니다. 정점 속성이 밀접하게 패킹되어 있으면 0을 사용할 수 있습니다."},{"name":"pointer","type":"const GLvoid*","description":"배열의 첫 번째 구성 요소의 첫 번째 정점 속성에 대한 오프셋을 지정합니다."}]'
  description="그리기 호출이 이루어질 때마다 정점 버퍼 데이터를 어떻게 해석해야 하는지 지정합니다. 해석 지정은 현재 바인딩된 정점 배열 객체에 저장되며 일부 상태 변경 시까지 유효합니다."
  example="glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(float), (void*)0);"
  tags='["Vertex Attributes", "Buffer Management"]'
/> 로 업데이트할 수 있습니다. 

```cpp 
// position attribute
glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 6 * sizeof(float), (void*)0);
glEnableVertexAttribArray(0);
// color attribute
glVertexAttribPointer(1, 3, GL_FLOAT, GL_FALSE, 6 * sizeof(float), (void*)(3* sizeof(float)));
glEnableVertexAttribArray(1);
```

 <Func 
  name="glVertexAttribPointer"
  params='[{"name":"index","type":"GLuint","description":"정점 속성의 인덱스를 지정합니다."},{"name":"size","type":"GLint","description":"정점 속성당 구성 요소의 수를 지정합니다. 1, 2, 3, 4 중 하나여야 합니다."},{"name":"type","type":"GLenum","description":"배열의 각 구성 요소의 데이터 타입을 지정합니다. GL_BYTE, GL_UNSIGNED_BYTE, GL_SHORT, GL_UNSIGNED_SHORT, GL_INT, GL_UNSIGNED_INT, GL_FLOAT, GL_DOUBLE 등이 있습니다."},{"name":"normalized","type":"GLboolean","description":"데이터가 정규화되어야 하는지 지정합니다. 정수 값의 경우 0에서 1 범위(부호 없는 값) 또는 -1에서 1 범위(부호 있는 값)로 매핑됩니다."},{"name":"stride","type":"GLsizei","description":"연속된 정점 속성 사이의 바이트 오프셋을 지정합니다. 정점 속성이 밀접하게 패킹되어 있으면 0을 사용할 수 있습니다."},{"name":"pointer","type":"const GLvoid*","description":"배열의 첫 번째 구성 요소의 첫 번째 정점 속성에 대한 오프셋을 지정합니다."}]'
  description="그리기 호출이 이루어질 때마다 정점 버퍼 데이터를 어떻게 해석해야 하는지 지정합니다. 해석 지정은 현재 바인딩된 정점 배열 객체에 저장되며 일부 상태 변경 시까지 유효합니다."
  example="glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(float), (void*)0);"
  tags='["Vertex Attributes", "Buffer Management"]'
/> 의 앞쪽 몇몇 인자들은 비교적 직관적입니다. 이번에는 속성 위치(location) 1에 정점 속성을 설정합니다. 
색상값은 `float` 3개 크기를 가지며, 값을 `정규화(normalize)` 하지 않습니다. 

이제 두개의 정점 속성이 있으므로, `stride`값을 다시 계산해야 합니다. 데이터 배열에서 다음 속성 값 (예: 다음 위치 벡터의 x 요소)으로 이동하려면 
총 6개의 float을 건너뛰어야 합니다. (위치 값 3개 + 색상 값 3개) 따라서 `stride` 값은 `6*sizeof(float)` 즉 24 바이트가 됩니다. 

또한 이번에는 `오프셋(offset)`을 지정해야 합니다. 각 정점에서 위치 데이터가 먼저 오므로, 위치 속성의 오프셋은 0입니다. 색상 속성은 위치 데이터 뒤에서 
시작하므로 , 오프셋은 3*sizeof(float) 바이트 , 즉 12바이트가 됩니다. 

프로그램을 실행하면 다음과 같은 이미지를 볼 수 있을 것입니다! 

![shaders3](./images/getting-started/shaders3.png)

만약 막혔다면 <LinkBlock url="https://learnopengl.com/code_viewer_gh.php?code=src/1.getting_started/3.2.shaders_interpolation/shaders_interpolation.cpp" text="여기"/> 에서 소스코드를 확인해 보세요

이미지는 아마 여러분이 예상했던 것과는 조금 다르게 보일 수 있습니다. 왜냐면 우리는 단 3개의 색상만 제공했는데 
실제로는 훨씬 풍부한 색상 팔레트가 나타났기 때문입니다. 
이는 모두 프래그먼트 쉐이더에서 일어나는 <Green>프래그먼트 보간(fragment interpolation)</Green> 때문입니다. 

삼각형을 렌더링 할때 레스터화(rasterization)단계에서는 원래 지정된 정점보다 훨씬 더 많은 프래그먼트가 생성됩니다. 
레스터라이저는 삼각형 모양 위에서 각 프래그먼트가 위치하는 곳을 기준으로 그 위치를 결정합니다. 
이 위치를 기반으로 프래그먼트 쉐이더의 모든 입력 변수 값들이 <Green>보간(interpolates)</Green> 됩니다. 
예를 들어, 어떤 선분의 윗점은 초록색이고 아랫점은 파란색이라고 해봅시다. 만약 어떤 프래그먼트가 선분 위에서 약 70% 지점에 위치한다면 
그 프래그먼트가 입력으로 받는 색상 속성은 초록색과 파란색의 선형 조합이 됩니다. 정확히 말하면 30% 파랑 + 70% 초록이 되는 것입니다. 

이것이 바로 우리의 삼각형에게 일어난 일입니다. 우리는 3개의 정점을 가졌고 따라서 3개의 색상을 지정했습니다. 
하지만 삼각형의 픽셀들을 보면, 실제로는 약 50,000개의 프래그먼트가 포함되어 있고, 프래그먼트 쉐이더는 이 픽셀들 사이에서 
색상을 <Green>보간(interpolates)</Green> 했습니다. 색상을 자세히 들여다 보면 이해가 될 겁니다. 빨강에서 파랑으로 갈때 
보라색을 거쳐 파랑으로 변하는 것을 볼 수 있죠 

프래그먼트 보간은 프래그먼트 쉐이더의 모든 입력 속성에 적용됩니다. 

## Our own shader class 우리만의 쉐이더 클래스 

쉐이더를 작성하고, 컴파일하고, 관리하는 일은 꽤 번거로울 수 있습니다. 쉐이더에 대한 마무리 터치를 해서 좀 더 우리를 편하게 만들어 봅시다. 
디스크에서 쉐이더를 읽고 , 컴파일 및 링크하고, 오류를 검사하고, 쉽게 사용할 수도 있는 쉐이더 클래스를 만들어서 이루어질 수 있습니다. 
이렇게 하면 지금까지 배운 지식들을 유용한 추상 객체로 캡슐화 하는 방법도 어느정도 이해할 수 있습니다. 

학습 목적과 이식성을 위해 쉐이더 클래스는 헤더 파일 하나에 전부 작성하겠습니다. 우선 필요한 include들을 추가하고 클래스 구조를 정의하는 
것부터 시작해 봅시다. 

```cpp 
#ifndef SHADER_H
#define SHADER_H

#include <glad/glad.h> // include glad to get all the required OpenGL headers
  
#include <string>
#include <fstream>
#include <sstream>
#include <iostream>
  

class Shader
{
public:
    // the program ID
    unsigned int ID;
  
    // constructor reads and builds the shader
    Shader(const char* vertexPath, const char* fragmentPath);
    // use/activate the shader
    void use();
    // utility uniform functions
    void setBool(const std::string &name, bool value) const;  
    void setInt(const std::string &name, int value) const;   
    void setFloat(const std::string &name, float value) const;
};
  
#endif
```

<Info>
헤더 파일의 맨 위에 여러 개의 전처리기 지시문(preprocessor directives) 를 사용했습니다. 이 작은 코드 줄들은 , 여러 파일에서 
쉐이더 헤더를 포함하더라도, 아직 포함되지 않았다면 그때만 컴파일러가 이 헤더파일을 포함하고 컴파일 하라고 알려줍니다. 
이렇게 하면 링킹 충돌(linking conflicts)를 방지할 수 있습니다. 
</Info>



<Collapsible title="링킹 충돌 (linking conflicts) 이란?" variant="info">

보통 C++에서 헤더파일(.h)은 클래스 선언 함수 선언 등을 담고 있고 여러 `.cpp`파일에서 공통으로 불러옵니다. 

```cpp 
#include "Shader.h"
#include "Renderer.h"
#include "Game.h"
```

문제는 `Render.cpp`와 `Game.cpp`가 둘다 `Shader.h`를 포함하게 되면 `Shader.h`가 두번 이상 컴파일 과정에 들어오게 됩니다. 
이때 `Shader.h` 내의 정의 (예: `unsigned int ID`) 가 중복되면 링커 단계에서 오류가 발생합니다. 
즉 같은 코드가 여러 번 들어와서 충돌하는 것을 링킹 충돌 이라고 합니다. 

</Collapsible>

쉐이더 클래스는 쉐이더 프로그램의 ID를 보관합니다. 이 클래스의 생성자는 
정점 쉐이더와 프래그먼트 쉐이더의 소스 파일 경로를 각각 요구하며, 이 소스들은 디스크에 단순한 텍스트 파일로 저장할 수 있습니다. 

추가로 작업을 더 간단하게 하기위해 몇 가지 유틸리티 함수도 넣었습니다. 
- <Red>use</Red>함수는 쉐이더 프로그램을 활성화하고 
- 모든 <Red>set...</Red> 함수들은 특정 uniform 위치를 조회한 뒤 그 값을 설정합니다. 

## Reading from file 파일에서 읽기 

우리는 C++ filestream 을 사용하여, 파일의 내용을 여러개의 문자열 객체로 읽어들이고 있습니다. 

```cpp 
Shader(const char* vertexPath, const char* fragmentPath)
{
    // 1. retrieve the vertex/fragment source code from filePath
    std::string vertexCode;
    std::string fragmentCode;
    std::ifstream vShaderFile;
    std::ifstream fShaderFile;
    // ensure ifstream objects can throw exceptions:
    vShaderFile.exceptions (std::ifstream::failbit | std::ifstream::badbit);
    fShaderFile.exceptions (std::ifstream::failbit | std::ifstream::badbit);
    try 
    {
        // open files
        vShaderFile.open(vertexPath);
        fShaderFile.open(fragmentPath);
        std::stringstream vShaderStream, fShaderStream;
        // read file's buffer contents into streams
        vShaderStream << vShaderFile.rdbuf();
        fShaderStream << fShaderFile.rdbuf();		
        // close file handlers
        vShaderFile.close();
        fShaderFile.close();
        // convert stream into string
        vertexCode   = vShaderStream.str();
        fragmentCode = fShaderStream.str();		
    }
    catch(std::ifstream::failure e)
    {
        std::cout << "ERROR::SHADER::FILE_NOT_SUCCESFULLY_READ" << std::endl;
    }
    const char* vShaderCode = vertexCode.c_str();
    const char* fShaderCode = fragmentCode.c_str();
    [...]
``` 
다음으로 우리는 쉐이더들을 컴파일하고 링크해야 합니다. 이때 컴파일이나 링크가 실패했는지 확인하고 
실패했다면 컴파일 시 발생한 오류를 출력합니다. 

이 과정은 디버깅시 매우 유용하며(결국엔 반드시 필요로 하게 됩니다) 에러 로그르 확인할 수 있게 해줍니다. 
```cpp 
// 2. compile shaders
unsigned int vertex, fragment;
int success;
char infoLog[512];
   
// vertex Shader
vertex = glCreateShader(GL_VERTEX_SHADER);
glShaderSource(vertex, 1, &vShaderCode, NULL);
glCompileShader(vertex);
// print compile errors if any
glGetShaderiv(vertex, GL_COMPILE_STATUS, &success);
if(!success)
{
    glGetShaderInfoLog(vertex, 512, NULL, infoLog);
    std::cout << "ERROR::SHADER::VERTEX::COMPILATION_FAILED\n" << infoLog << std::endl;
};
  
// similiar for Fragment Shader
[...]
  
// shader Program
ID = glCreateProgram();
glAttachShader(ID, vertex);
glAttachShader(ID, fragment);
glLinkProgram(ID);
// print linking errors if any
glGetProgramiv(ID, GL_LINK_STATUS, &success);
if(!success)
{
    glGetProgramInfoLog(ID, 512, NULL, infoLog);
    std::cout << "ERROR::SHADER::PROGRAM::LINKING_FAILED\n" << infoLog << std::endl;
}
  
// delete the shaders as they're linked into our program now and no longer necessary
glDeleteShader(vertex);
```

<Red>use</Red> 함수는 매우 직관적입니다. 

```cpp 
void use() 
{ 
    glUseProgram(ID);
}  
```

uniform setter 함수들도 그렇죠 

```cpp 
void setBool(const std::string &name, bool value) const
{         
    glUniform1i(glGetUniformLocation(ID, name.c_str()), (int)value); 
}
void setInt(const std::string &name, int value) const
{ 
    glUniform1i(glGetUniformLocation(ID, name.c_str()), value); 
}
void setFloat(const std::string &name, float value) const
{ 
    glUniform1f(glGetUniformLocation(ID, name.c_str()), value); 
} 
```

이제 됐습니다. <LinkBlock url="https://learnopengl.com/code_viewer_gh.php?code=includes/learnopengl/shader_s.h" text="shader class"/> 가 완성되었습니다. 
쉐이더 클래스(shader class)를 사용하는 것은 꽤 쉽습니다. 우리는 쉐이더 오브젝트를 생성해서 그 시점부터 사용하면 됩니다. 


```cpp 
Shader ourShader("path/to/shaders/shader.vs", "path/to/shaders/shader.fs");
[...]
while(...)
{
    ourShader.use();
    ourShader.setFloat("someUniform", 1.0f);
    DrawStuff();
}
```

여기서 우리는 정점 쉐이더와 프래그먼트 쉐이더의 소스코드를 각각 `shader.vs` 와 `shader.fs`라는 두파일에 저장했습니다. 
쉐이더 파일 이름은 자유롭게 정할 수 있으며, 개인적으로는 `.vs`(vertex shader : 정점 쉐이더) `fs` (fragment shader: 프래그먼트 쉐이더) 확장자가 
직관적이라 선호합니다. 

방금 만든 <LinkBlock url="https://learnopengl.com/code_viewer_gh.php?code=includes/learnopengl/shader_s.h" text="shader class"/>를 사용한 코드를 <LinkBlock url="https://learnopengl.com/code_viewer_gh.php?code=src/1.getting_started/3.3.shaders_class/shaders_class.cpp" text="여기"/> 서 찾을 수 있습니다. 
참고로 쉐이더 파일 경로를 클릭하면 쉐이더 소스코드를 직접 확인할 수 있습니다. 

## 연습 문제 
<NumberedList>
 <NumberedItem> 정점 쉐이더를 수정해서 삼각형이 거꾸로 뒤집히도록 만드세요 -> <LinkBlock url="https://learnopengl.com/code_viewer_gh.php?code=src/1.getting_started/3.4.shaders_exercise1/shaders_exercise1.cpp" text="해답"/></NumberedItem>
  <NumberedItem> uniform 을 사용해 수평 오프셋 값을 지정하고 정점 쉐이더에서 이 값을 이용해 삼각형을 화면의 오른쪽으로 이동시키세요 -> <LinkBlock url="https://learnopengl.com/code_viewer_gh.php?code=src/1.getting_started/3.5.shaders_exercise2/shaders_exercise2.cpp" text="해답"/></NumberedItem>
 <NumberedItem> out 키워드를 사용해 정점 위치를 프래그먼트 셰이더로 전달하고, 프래그먼트의 색상을 이 정점 위치 값으로 설정하세요. (이때 삼각형 내부에서도 정점 위치 값이 보간되는 것을 확인할 수 있습니다.)
이 과제를 완료했다면, 다음 질문에 답해보세요:
“왜 삼각형의 왼쪽 아래 부분은 검게 보일까요?” → <LinkBlock url="https://learnopengl.com/code_viewer_gh.php?code=src/1.getting_started/3.6.shaders_exercise3/shaders_exercise3.cpp" text="해답"/></NumberedItem>
</NumberedList>




<Collapsible title="왜 삼각형의 왼쪽 아래 부분은 검게 보일까요?의 정답" variant="info">

우리가 정점 위치(x,y,z)를 프래그먼트 쉐이더로 넘기고, 그 값을 색상 그대로 출력하면 이런 코드가 됩니다. 

```cppout vec4 FragColor;
in vec3 vertexPos;   // 정점 셰이더에서 넘어온 위치 값

void main() {
    FragColor = vec4(vertexPos, 1.0);
}

```

즉, 픽셀 색상이 곧 정점 좌표 값입니다. 

### OpenGL의 좌표 범위 (NDC)

OpenGL에서 정점 쉐이더의 출력 (gl_Position)은 Normalized Device Coordinate(NDC)로 변환 됩니다.
이 값의 범위는 -1.0 ~ 1.0 입니다. 
- x: 왼쪽 -1.0 → 오른쪽 +1.0
- y: 아래 -1.0 → 위쪽 +1.0
- z: 화면 안쪽 -1.0 → 바깥쪽 +1.0

문제는 색상은 0.0 ~ 1.0 범위로만 의미가 있다는 점입니다. 삼각형의 왼쪽 아래는 좌표가 (-x,-y) 즉 음수 범위에 있기 때문에 
프래그먼트 쉐이더에서 그대로 색상을 출력하면 -> 음수 값은 잘려서 0이 되기때문에 검정으로 보이는 것입니다.

![shader_answer_3](./images/getting-started/shader_answer_3.png)
</Collapsible>