# Hello Triangle 

OpenGL 에서 모든 것은 3D 공간속에 있습니다다. 하지만 화면이나 윈도우는 2D 픽셀 배열이기 때문에 
OpenGL의 많은 부분은 모든 3D 좌표들을 2D 픽셀로 변형하여 스크린에 맞도록 하는 것입니다. 
3D좌표를 2D 픽셀로 변형하는 것은 OpenGL의 <Green>graphics pipeline(그래픽스 파이프라인)</Green>이 맡게됩니니다. 
graphics pipeline은 두개의 큰 부분으로 나뉠 수 있습니다.  

<NumberedList>
<NumberedItem>첫번째 부분은 3D 좌표를 2D 좌표로 변환하는 과정</NumberedItem>
<NumberedItem>두번째 부분은 2D 좌표를 실제 색이 있는 픽셀로 변환하는 과정입니다.</NumberedItem>
</NumberedList> 

이번 장에서는 그래픽스 파이프라인을 간단히 살펴보고, 우리가 멋진 픽셀들을 만들기 위해 이를 어떻게
활용할 수 있는지 알아보겠습니다. 

그래픽스 파이프라인은 입력으로 일련의 3D 좌표를 받아들이고, 이를 화면의 색이 있는 2D 픽셀로 변환합니다. 
그래픽스 파이프라인은 여러 단계로 나눌 수 있으며, 각 단계는 이전 단계의 출력을 입력으로 받아야합니다. 
이 모든 단계는 매우 전문화 되어있고 (하나의 특정한 기능만 처리합니다.) 
쉽게 병렬적으로 처리 될 수 있습니다. 이것들의 병렬적인 성질때문에 오늘날의 그래픽 카드에는 수천 개의 작은 처리 코어가 존재하여 데이터를
파이프라인 안에서 빠르게 처리할 수 있습니다. 
이러한 처리 코어들은 파이프라인의 각 단계에서 실행되는 작은 프로그램을 구동합니다. 이 작은 프로그램들을 쉐이더(shader) 라고 부릅니다.

<TranslatorNote type="clarification" author="이도경" collapsible={true} defaultOpen={false}>
GPU 코어 
- CPU는 몇 개의 코어를 차례차례 계산
- GPU는 단순한 코어를 수천개나 넣어서 계산을 동시에 처리 

따라서 화면에 있는 수많은 점 픽셀을 한꺼 번에 처리할 수 있다. 


쉐이더 (Shader) = 작은 프로그램
- GPU 코어가 실행하는 짧은 코드 조각 이 코드가 정점 하나당 1번, 픽셀 하나당 1번 실행 된다. 


GPU는 수천개의 작은 코어로 쉐이더라는 짧은 프로그램을 동시에 실행해서, 수많은 점과 픽셀을 빠르게 계산해 화면을 그려준다. 
</TranslatorNote> 

쉐이더중 일부는 개발자가 직접 수정할 수 있도록 구성되어 있습니다. 따라서 기존의 기본 쉐이더를 자신만의 쉐이더로 교체할 수 있습니다. 
이렇게 하면 파이프라인 특정 부분을 더 세밀하게 제어할 수 있으며, GPU에서 실행되기 때문에 CPU의 연산 시간을 아낄 수 있습니다. 
쉐이더는 OpenGL 쉐이딩 언어 (GLSL) 로 작성되며, 다음 장에서 이를 깊이 다루게 될 것입니다. 

아래 그림은 그래픽스 파이프라인의 모든 단계를 추상적으로 나타낸 것입니다. 파란색으로 표시된 박스는 우리가 직접 쉐이더를 삽입할 수 있는 구간 입니다. 

![pipeline](./images/getting-started/pipeline.png)

보시다시피, 그래픽스 파이프라인은 정점 데이터를 완전히 렌더링된 픽셀로 변환하는 과정에서 각각 특정한 역할만 담당하는 많은 단계들로 이루어져 있습니다. 
여기서는 파이프라인이 어떻게 동작하는지에 대해 전체적인 그림을 설명하기 위해 간단히 설명하겠습니다. 

그래픽스 파이프라인 (graphics pipeline)의 입력으로는, 우리는 삼각형을 이루기 위한 3개의 3D 좌표 리스트를 넘겨줍니다. 
이 배열을 여기서는 정점 데이터 (Vertex Data) 라고 부릅니다. 정점(Vertex) 란 3D 좌표마다 주어지는 데이터 묶음을 의미합니다. 
정점의 데이터는 정점 속성(Vertex Attribute)으로 표현되며, 이 속성에는 우리가 원하는 어떤 값이든 넣을 수 있습니다. 하지만 간단히 
하기위해 이 튜토리얼 에서는 각 정점이 단지 3D 위치와 색상 값만 가진다고 가정하겠습니다. 

<Info>

OpenGL이 여러분이 넘겨준 좌표와 색상 값을 어떻게 처리해야 할지 알 수 있도록 하기 위해 , 우리는 이 데이터로 어떤 형태의 렌더링을 하고싶은지
힌트를 주어야합니다. 즉 이 데이터를 점들의 집합으로 렌더링할지 아니면 삼각형들의 집합으로 렌더링 할지, 혹은 하나의 긴 선으로 만들 수도 있겠죠?
이러한 힌트들을 `프리미티브(Primitive)` 라고 부르며 OpenGL의 그리기 명령을 호출할때 전달합니다. 그 예시로는 
`GL_POINTS` , `GL_TRIANGLES` 그리고 `GL_LINE_STRIP` 등이 있습니다. 

</Info> 

파이프라인의 첫번째 단계는 <Green>정점 쉐이더(Vertex Shader)</Green>로 , 입력으로 하나의 정점을 받습니다. 정점 쉐이더의 주요 목적은 3D 좌표를 
다른 3D 좌표로 변환하는 것입니다.(이건 나중에 더 자세히 설명하죠) 또한 정점 속성에 대한 기초적인 처리를 할 수 있습니다. 

정점 쉐이더의 단계의 출력은 선택적으로 <Green>지오메트리 쉐이더 (Geometry Shader)</Green> 로 전달될 수 있습니다. 
지오메드리 쉐이더는 입력으로 하나의 프리미티브를 이루는 정점 집합을 받고, 새로운 정점들을 내보내어 새로운 도형(프리미티브)를 생성할 수
있는 기능을 가지고 있습니다. 이 예시에서는 주어진 도형을 기반으로 두번째 삼각형을 생성합니다. 

**프리미티브 조립 단계(Primitive Assembly stage)** 는 정점 셰이더(또는 지오메트리 셰이더)에서 출력된, 하나 이상의 프리미티브를 이루는 모든 정점(만약 GL_POINTS가 선택되었다면 단일 정점)을 입력으로 받아, 주어진 프리미티브 형태에 맞게 점들을 조립합니다. 이 경우에는 두 개의 삼각형이 조립됩니다.

프리미티브 조립 단계의 출력은 <Green>레스터라이제이션 단계(rasterization state)</Green>으로 넘어가 프리미티브 결과들을 화면에 대응하는 
픽셀들로 변환합니다. 이는 프래그먼트(fragments)가 되어 프래그먼트 쉐이더(fragment shader)가 사용할 수 있도록 합니다. 
프래그먼트 쉐이더가 돌아가기 전에 <Green>클리핑(cliping)</Green>이 수행됩니다. 클리핑은 모든 화면 밖에 위치한 모든 프래그먼트를 제거하여 
성능을 향상 시킵니다. 


<Info>
프래그먼트(fragment)란 OpenGL이 하나의 픽셀을 생성(렌더)하기 위한 모든 데이터를 일컫습니다. 
</Info>

<Green>프래그먼트 쉐이더(fragment shader)</Green>의 주요 목적은 최종적인 픽셀의 색상을 계산하는 것입니다. 보통 이 단계에서 
OpenGL의 고급 효과들이 대부분 발생합니다. 일반적으로 프래그먼트 쉐이더는 최종 픽셀 색상을 계산하는 데 사용할 수 있는 
3D장면에 대한 데이터(예: 빛 , 그림자, 광원의 색상 등)을 포함합니다. 


모든 픽셀에 대한 색상값이 계산된 후, 최종 객체는 알파 테스트와 블랜딩 (Alpha Test & Blending) 단계라고 불리는 한단계를 더 거칩니다. 
이 단계에서는 프래그먼트의 깊이(Depth) 와 스텐실 (Stencil) 값 (이에 대해서는 나중에 다룹니다)을 검사하여, 해당 프래그먼트가 
다른 객체들 보다 앞에 있는지 뒤에 있는지를 확인하고, 필요하다면 버려집니다. 또한 이 단계에서는 알파 값(알파 값은 객체의 불투명도를 정의함)을 
확인하고 여러 객체를 이에 따라 섞어 표시합니다. 따라서 프레그먼트 쉐이더에서 어떤 픽셀의 출력 색상이 계산되었더라도, 여러 삼각형이
동시에 렌더링 되는 상황에서는 최종적으로 화면에 표시되는 픽셀 색상이 완전히 달라질 수도 있습니다. 

보시다시피 그래픽스 파이프라인은 꽤 복잡하며 다양한 설정 가능한 부분들을 포함하고 있습니다. 하지만 대부분의 경우 우리는 
정점 쉐이더(Vertex Shader)와 프래그먼트 쉐이더(Fragment Shader)만 다루면 됩니다. 지오메트리 쉐이더(Geometry shader)는 선택 사항이며
보통 기본 상태로 둡니다. 또한 여기서는 다루지 않았지만 테셀레이션(Tessellation) 단계와 트랜스폼 피드백 루프(Transform Feedback Loop) 같은
기능도 존재합니다. 

현대 OpenGL에서는 반드시 사용자가 직접 정의한 정점 쉐이더와 프레그먼트 쉐이더르 작성해야 합니다. (GPU에서는 기본 제공되는 정점/프래그먼트 쉐이더가 없습니다)
이 때문에 현대 OpenGL을 처음 배우기가 어렵습니다. 삼각형 하나를 만들때에도 꽤 많은 지식이 필요하기 때문입니다. 
하지만 이번장의 끝에서 삼각형을 직접 만들어보면, 그래픽스 프로그래밍에 대해 훨씬더 많은 것을 알게 될 것입니다. 


<TranslatorNote type="clarification" author="이도경" collapsible={true} defaultOpen={false}>
간단한 정리 삼각형을 그리기 위해서 

<NumberedList>
<NumberedItem>**정점 데이터**: 삼각형의 꼭짓점 3개의 좌표와 색깔을 준비한다.(예, 왼쪽 위 빨강, 오른쪽 위 초록, 아래 파랑)</NumberedItem>
<NumberedItem>**정점 쉐이더**: 이 좌표들을 화면 안에서 어디에 그릴지 계산해 준다. (3D 공간 좌표 -> 화면에 보이기 위한 2D 좌표로 변환)</NumberedItem>
<NumberedItem>**프리미티브 조립**: 꼭짓점들을 이어서 삼각형 모양을 만든다.</NumberedItem>
<NumberedItem>**레스터화**: 삼각형 안을 픽셀 단위로 잘게 쪼개서 "이곳을 색칠해야지" 하고 색칠될 픽셀 후보(프래그먼트)들을 만든다. (예: 마치 삼각형 안을 색연필로 칠할 칸을 잘게 나누는 것처럼)</NumberedItem>
<NumberedItem>**프래그먼트 쉐이더**: 각 픽셀 후보마다 "어떤 색으로 칠하지?" 를 결정한다.</NumberedItem>
<NumberedItem>**테스트 & 블렌딩**: 계산된 픽셀이 다른 물체 앞에 있으면 남기고, 뒤에있으면 지우는 작업 또 유리 같은 건 투명도 값을 이용해서 섞어준다.</NumberedItem>
<NumberedItem>**최종화면 출력**: 픽셀들이 다 색칠되어 삼각형 완성!</NumberedItem>
</NumberedList>
</TranslatorNote> 


## Vertex input (정점 입력)

무언가를 그리기 시작하기 위해 우리는 우선  OpenGL에게 정점 데이터(vertex data)를 줍니다다. OpenGL은 3D 그래픽 라이브러리 이기 때문에 
모든 OpenGL에서 우리가 특정하는 좌표들은 3D 형태입니다. (x,y그리고 z 좌표) OpenGL은 단순히 모든 3D좌표를 화면의 2D 픽셀로 변환하지 않습니다.
OpenGL은 오직 특정한 범위 안에 있는 3D좌표만 처리합니다. 이 범위란 x,y,z 모든 축에서 -1.0 ~ 1.0 사이인데 이를 **정규화 장치 좌표(Normalized Device Coordinateds, NDC)**
라고 부릅니다. 이 범위 안에 있는 좌표들만 화면에 보이게 되고, 이 범위를 벗어난 좌표들은 화면에 보이지 않습니다. 

우리는 삼각형 하나를 그리려고 하므로, 총 세개의 정점을 지정해야합니다. 각 정점은 3D위치를 가져야하고, 이를 OpenGL의 가시 영역인 
정규화 장치 좌표 (NDC) 범위 안에서 float 배열로 정의합니다. 

```cpp

float vertices[] = {
    -0.5f, -0.5f, 0.0f,
     0.5f, -0.5f, 0.0f,
     0.0f,  0.5f, 0.0f
};  
```

OpenGL은 3D공간이므로 우리는 2D 공간에 그려질 삼각형의 z 좌표를 모두 0.0으로 그립니다. 
이것은 삼각형의 깊이(Depth)를 모두 똑같도록 만들고 2D 삼각형 처럼 보이게 할 것입니다. 


<Info>
#### Normalized Device Coordinates : 정규화 장치 좌표 (NDC)

정점 좌표가 정점 쉐이더에서 처리되고 나면, 그것들은 정규화 장치 좌표라는 작은 공간안에 있게 됩니다. 이 좌표계에서는 x,y,z값이 모두
-1.0 ~ 1.0 범위 안에 있습니다. 만약 어떤 좌표가 이 범위를 벗어나면 해당 좌표는 잘려서 화면에 보이지 않게 됩니다. 
아래 그림은 우리가 지정한 삼각형을 정규화 장치 좌표 (NDC) 안에 표시한 예시입니다. (Z축은 무시)
![ndc](./images/getting-started/ndc.png)

보통의 화면 좌표와는 달리 , 이 좌표계에서는 Y축이 위쪽 방향이 양수이고 (0.0) 좌표는 화면의 왼쪽 위가 아니라 
정중앙에 있습니다. 결국 모든 좌표는 이 정규화 장치 좌표 공간안에 들어와야 화면에 보일 수 있습니다. 

정규화 장치 좌표(NDC)로 변환된 좌표들은 이후에 우리가 <Func 
  name="glViewport"
  params='[{"name":"x","type":"GLint","description":"뷰포트 사각형의 왼쪽 x좌표입니다. 윈도우 내 위치를 픽셀 기준으로 설정합니다."},{"name":"y","type":"GLint","description":"뷰포트 사각형의 아래쪽 y좌표입니다. OpenGL에서는 y=0이 윈도우의 하단을 의미합니다."},{"name":"width","type":"GLsizei","description":"뷰포트의 가로 너비를 지정합니다."},{"name":"height","type":"GLsizei","description":"뷰포트의 세로 높이를 지정합니다."}]'
  description="이 함수는 OpenGL 렌더링을 위한 실제 윈도우 내 렌더링 영역(뷰포트)을 설정합니다. 뷰포트는 정규화 장치 좌표(-1 ~ 1 범위)를 윈도우 좌표로 매핑하는 기준이 됩니다. 지정된 좌표를 통해 OpenGL이 데이터를 창 내 어느 영역에 표시할지 결정합니다."
  example="glViewport(0, 0, 800, 600);"
  tags='["Initialization"]'
/> 함수로 지정한 데이터를 이용해 뷰포트 변환(Viewport Transform)을 거쳐 스크린 좌표(Screen-space coordinates)로 변환됩니다. 
이렇게 변환된 화면 좌표들은 다시 프래그먼트 쉐이더(Fragment Shader)의 입력으로 들어가는 프래그먼트(Fragment)들로 나뉘게 됩니다. 

</Info> 

정점 데이터를 정의했으니 이제 이것을 그래픽스 파이프라인의 첫 번째 단계인 **정점 셰이더(Vertex Shader)** 에 
입력으로 보내고 싶습니다. 
이 작업은 GPU 메모리에 정점 데이터를 저장할 메모리를 만들고,
OpenGL이 그 메모리를 어떻게 해석해야 하는지 설정하며,
데이터를 그래픽 카드로 어떻게 보낼지를 지정하는 과정을 통해 이루어집니다. 
그 후 정점 셰이더는 우리가 지시한 만큼의 정점을 해당 메모리에서 가져와 처리하게 됩니다.

이 메모리들을 위리는 정점 버퍼 객체(Vertex Buffer Objects : VBO)로 관리하게 됩니다. 
VBO는 대량의 정점들을 GPU 메모리에 저장할 수 있게 해줍니다. 
이러한 버퍼 객체를 사용하는 것의 장점은 정점을 하나씩 GPU로 보내지 않고 큰 덩어리의 데이터들을 한번에 그래픽스 카드로 보낼 수 있게 해줍니다. 
만약 충분한 메모리가 남아있으면 여기에 저장할 수도 있습니다. 
CPU에서 GPU(Graphics Card)로 데이터를 보내는 작업은 상대적으로 느리기 때문에, 가능하다면 많은 데이터를 한번에 보내는게 좋겠죠 
데이터가 GPU메모리에 전달되고 나면 정점 쉐이더는 거의 즉시 모든 정점들에 매우 빠르게 접근할 수 있습니다. 

VBO는 우리가 OpenGL 소개 장에서 언급했던 OpenGL 객체의 거의 첫 등장입니다. OpenGL의 다른 객체들과 마찬가지로 
버퍼에도 고유한 ID가 부여됩니다. 따라서 
<Func 
  name="glGenBuffers"
  params='[{"name":"n","type":"GLsizei","description":"생성할 버퍼 객체의 개수입니다."},{"name":"buffers","type":"GLuint*","description":"생성된 버퍼 객체의 ID들이 저장될 배열의 포인터입니다."}]'
  description="OpenGL에서 하나 또는 여러 개의 버퍼 객체를 생성합니다. 버퍼 객체는 정점 데이터, 인덱스 데이터 등을 GPU 메모리에 저장하기 위해 사용됩니다. 생성된 각 버퍼 객체에는 고유한 ID가 부여되며, 이 ID를 통해 해당 버퍼를 참조할 수 있습니다."
  example="GLuint VBO; // 버퍼 ID를 저장할 변수\nglGenBuffers(1, &VBO); // 1개의 버퍼 생성\n\n// 여러 개 생성하는 경우\nGLuint buffers[3];\nglGenBuffers(3, buffers); // 3개의 버퍼 생성"
  tags='["Buffer Management", "OpenGL Objects"]'
/> 를 사용해 버퍼 ID를 생성할 수 있습니다. 

```cpp
unsigned int VBO;
glGenBuffers(1, &VBO);  
```


<Collapsible title="OpenGL 객체" variant="info">

### OpenGL 에서의 객체란

OpenGL에서 객체란 OpenGL 상태의 일부분을 대표하는 설정값들의 집합입니다. 
예를 들어, 하나의 객체는 그리기 창(window)의 설정을 나타낼 수 있으며 
이 객체에는 창의 크기, 색상 수, 이름 등 다양한 옵션션을 설정할 수 있습니다. 

### 객체의 장점 

OpenGL에서 객체를 사용하면 여러 개의 객체를 만들어 따로따로 설정할 수 있고,
작업 시점에 맞춰 원하는 객체를 필요할 때마다 바인딩하여 사용할 수 있습니다.

예를 들어: 3D 모델 객체를 각각 하나의 OpenGL 객체로 만들 수 있습니다. (예: 집, 캐릭터 등) 미리 설정해 둔 각 객체를 그릴 때마다 바인딩만 하면 되고,
다시 설정을 반복하지 않아도 됩니다.

</Collapsible>


<TranslatorNote type="clarification" author="이도경" collapsible={true} defaultOpen={false}>

#### OpenGL에서 오브젝트 = 객체 (Object)란?
OpenGL은 화면에 뭔가를 그릴때 GPU안에 여러 자원을 만들어서 관리합니다. 
이 자원들을 오브젝트(Object)라고 부릅니다.  

#### 왜 ID가 필요할까?
OpenGL은 C 함수 기반이라서 객체를 직접 다루지 못합니다. (객체지향 언어가 아니기 때문에 클래스/객체 형태로 다루지 못합니다. 
대신 함수와 정수 ID로 자원을 관리합니다.)
그래서 GPU에 뭔가를 만들면 OpenGL은 그걸 가리키는 숫자 ID를 줍니다. (마치 주민등록 번호 처럼 번호 = GPU 메모리 자원 으로 연결되죠)
나중에 이 ID를 다시 불러와서 (glBindBuffer) 쓰면 , GPU가 그 자원을 찾아서 사용합니다. 

#### VBO의 경우 
VBO = 정점 데이터를 담는 GPU 메모리 상자 
VBO를 하나 만들어 달라 요청하면 OpenGL이 GPU에 VBO 공간을 만들고 그걸 가리키는 ID를 돌려주는 것입니다. 
그 ID 변수를 저장해 두었다가 이후에 데이터 넣기/바인딩/삭제 같은 작업을 합니다.


</TranslatorNote> 


OpenGL은 많은 타입의 버퍼 오브젝트(객체)를 가지고 있습니다. 그중 정점 버퍼의 오브젝트 타입은 <Blue>GL_ARRAY_BUFFER</Blue> 입니다. 
OpenGL은 우리가 여러 버퍼들을 그들 각자의 타입만 다르다면 한번에 바인딩 할 수 있게 해줍니다. 
우리는 새롭게 생성된 버퍼를 <Blue>GL_ARRAY_BUFFER</Blue> 타겟으로 전달해 줄수 있습니다. 바로 <Func 
  name="glBindBuffer"
  params='[{"name":"target","type":"GLenum","description":"바인딩할 버퍼의 타입을 지정합니다. 가장 일반적인 것은 GL_ARRAY_BUFFER와 GL_ELEMENT_ARRAY_BUFFER입니다."},{"name":"buffer","type":"GLuint","description":"바인딩할 버퍼 객체의 ID입니다. 0을 전달하면 현재 바인딩된 버퍼를 해제합니다."}]'
  description="버퍼 객체를 현재 버퍼 타입 타겟에 바인딩합니다. 한 번에 각 버퍼 타입당 하나의 버퍼만 바인딩될 수 있습니다. 버퍼를 바인딩하면 해당 타입에 대한 모든 후속 버퍼 작업이 현재 바인딩된 버퍼에 적용됩니다."
  example="glBindBuffer(GL_ARRAY_BUFFER, VBO);\n// 이제 GL_ARRAY_BUFFER 타겟에 대한 모든 작업이 VBO에 적용됩니다\n\n// 바인딩 해제\nglBindBuffer(GL_ARRAY_BUFFER, 0);"
  tags='["Buffer Management", "OpenGL State"]'
/> 함수를 사용해서 말이죠.

```cpp
glBindBuffer(GL_ARRAY_BUFFER, VBO);  
```

이 시점부터 우리가 만드는 어떤 <Blue>GL_ARRAY_BUFFER</Blue> 타깃에 대해 호출하는 모든 버퍼 관련 함수는 현재 바인딩된 버퍼(VBO)
를 설정하게 됩니다. 그 다음 <Func 
  name="glBufferData"
  params='[{"name":"target","type":"GLenum","description":"버퍼 객체의 타겟을 지정합니다. 가장 일반적인 것은 GL_ARRAY_BUFFER와 GL_ELEMENT_ARRAY_BUFFER입니다."},{"name":"size","type":"GLsizeiptr","description":"버퍼 객체의 새로운 데이터 저장소 크기를 바이트 단위로 지정합니다."},{"name":"data","type":"const GLvoid*","description":"버퍼로 복사될 데이터에 대한 포인터입니다. NULL이면 할당된 메모리를 비워둡니다."},{"name":"usage","type":"GLenum","description":"데이터의 예상 사용 패턴입니다. 가장 일반적인 것은 GL_STATIC_DRAW, GL_DYNAMIC_DRAW, GL_STREAM_DRAW입니다."}]'
  description="현재 바인딩된 버퍼 객체에 메모리를 할당하고 데이터를 저장합니다. 버퍼 객체를 추가/편집하는 여러 함수 중 하나입니다. 이 함수는 이전에 할당된 데이터를 새로운 데이터로 대체합니다."
  example="GLfloat vertices[] = {\n    0.0f,  0.5f, 0.0f,\n   -0.5f, -0.5f, 0.0f,\n    0.5f, -0.5f, 0.0f\n};\nglBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW);"
  tags='["Buffer Management", "Data Upload"]'
/> 함수를 호출해서  을 호출해서 미리 정의한 정점 배열을 현재 바인딩된 버퍼의 메모리로 복사합니다. 

```cpp

glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW);
```
<Func 
  name="glBufferData"
  params='[{"name":"target","type":"GLenum","description":"버퍼 객체의 타겟을 지정합니다. 가장 일반적인 것은 GL_ARRAY_BUFFER와 GL_ELEMENT_ARRAY_BUFFER입니다."},{"name":"size","type":"GLsizeiptr","description":"버퍼 객체의 새로운 데이터 저장소 크기를 바이트 단위로 지정합니다."},{"name":"data","type":"const GLvoid*","description":"버퍼로 복사될 데이터에 대한 포인터입니다. NULL이면 할당된 메모리를 비워둡니다."},{"name":"usage","type":"GLenum","description":"데이터의 예상 사용 패턴입니다. 가장 일반적인 것은 GL_STATIC_DRAW, GL_DYNAMIC_DRAW, GL_STREAM_DRAW입니다."}]'
  description="현재 바인딩된 버퍼 객체에 메모리를 할당하고 데이터를 저장합니다. 버퍼 객체를 추가/편집하는 여러 함수 중 하나입니다. 이 함수는 이전에 할당된 데이터를 새로운 데이터로 대체합니다."
  example="GLfloat vertices[] = {\n    0.0f,  0.5f, 0.0f,\n   -0.5f, -0.5f, 0.0f,\n    0.5f, -0.5f, 0.0f\n};\nglBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW);"
  tags='["Buffer Management", "Data Upload"]'
/> 는  사용자 정의 데이터를 현재 바인딩된 버퍼에 복사하는 데 특화된 함수입니다. 
<NumberedList>
<NumberedItem>**첫번째 인자**: 우리가 데이터를 복사하려는 버퍼의 타입을 지정합니다. 여기서는 GL_ARRAY_BUFFER 타깃에 현재 바인딩된 정점 버퍼(VBO)입니다.</NumberedItem>
<NumberedItem>**두번째 인자**: 버퍼에 전달할 데이터의 크기(바이트 단위)를 지정합니다. 보통 정점 데이터의 sizeof을 사용하면 충분합니다.</NumberedItem>
<NumberedItem>**세번째 인자**: 우리가 실제로 전송하려는 데이터입니다.</NumberedItem>
<NumberedItem>**네번째 인자**: 그래픽 카드가 주어진 데이터를 어떻게 관리해야하는지를 지정합니다. 이 값은 3가지 형태가 있습니다.</NumberedItem>
</NumberedList> 

- <Blue>GL_STREAM_DRAW</Blue> 데이터를 한번만설정하고 , GPU에서 많아야 몇번만 사용합니다. 
- <Blue>GL_STATIC_DRAW</Blue> 데이터를 한 번만 설정하고 여러 번 사용합니다.
- <Blue>GL_DYNAMIC_DRAW</Blue> 데이터를 자주 변경하면서 여러 번 사용합니다.

삼각형의 위치 데이터는 변하지 않고, 많이 사용되며, 모든 렌더 호출마다 동일하게 유지되므로 <Blue>GL_STATIC_DRAW</Blue> 를 사용하는 것이
가장 적합합니다. 반대로 데이터가 자주 변경될 가능성이 있는 버퍼라면,<Blue>GL_DYNAMIC_DRAW</Blue> 를 사용하면 그래픽 카드가 더 빠른 쓰기가 가능한
메모리에 데이터를 배치하도록 보장합니다. 

지금까지 우리는 VBO(정점 버퍼 객체=오브젝트)가 관리하는 그래픽 카드 메모리에 정점 데이터를 저장했습니다. 
이제 이 데이터를 실제로 처리할 정점 쉐이더와 프래그먼트 쉐이더를 만들어야하므로 다음 단계로 넘어가겠습니다. 


