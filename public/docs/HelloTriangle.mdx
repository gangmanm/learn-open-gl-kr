# Hello Triangle 

OpenGL 에서 모든 것은 3D 공간속에 있습니다다. 하지만 화면이나 윈도우는 2D 픽셀 배열이기 때문에 
OpenGL의 많은 부분은 모든 3D 좌표들을 2D 픽셀로 변형하여 스크린에 맞도록 하는 것입니다. 
3D좌표를 2D 픽셀로 변형하는 것은 OpenGL의 <Green>graphics pipeline(그래픽스 파이프라인)</Green>이 맡게됩니니다. 
graphics pipeline은 두개의 큰 부분으로 나뉠 수 있습니다.  

<NumberedList>
<NumberedItem>첫번째 부분은 3D 좌표를 2D 좌표로 변환하는 과정</NumberedItem>
<NumberedItem>두번째 부분은 2D 좌표를 실제 색이 있는 픽셀로 변환하는 과정입니다.</NumberedItem>
</NumberedList> 

이번 장에서는 그래픽스 파이프라인을 간단히 살펴보고, 우리가 멋진 픽셀들을 만들기 위해 이를 어떻게
활용할 수 있는지 알아보겠습니다. 

그래픽스 파이프라인은 입력으로 일련의 3D 좌표를 받아들이고, 이를 화면의 색이 있는 2D 픽셀로 변환합니다. 
그래픽스 파이프라인은 여러 단계로 나눌 수 있으며, 각 단계는 이전 단계의 출력을 입력으로 받아야합니다. 
이 모든 단계는 매우 전문화 되어있고 (하나의 특정한 기능만 처리합니다.) 
쉽게 병렬적으로 처리 될 수 있습니다. 이것들의 병렬적인 성질때문에 오늘날의 그래픽 카드에는 수천 개의 작은 처리 코어가 존재하여 데이터를
파이프라인 안에서 빠르게 처리할 수 있습니다. 
이러한 처리 코어들은 파이프라인의 각 단계에서 실행되는 작은 프로그램을 구동합니다. 이 작은 프로그램들을 쉐이더(shader) 라고 부릅니다.

<TranslatorNote type="clarification" author="이도경" >
GPU 코어 
- CPU는 몇 개의 코어를 차례차례 계산
- GPU는 단순한 코어를 수천개나 넣어서 계산을 동시에 처리 

따라서 화면에 있는 수많은 점 픽셀을 한꺼 번에 처리할 수 있다. 


쉐이더 (Shader) = 작은 프로그램
- GPU 코어가 실행하는 짧은 코드 조각 이 코드가 정점 하나당 1번, 픽셀 하나당 1번 실행 된다. 


GPU는 수천개의 작은 코어로 쉐이더라는 짧은 프로그램을 동시에 실행해서, 수많은 점과 픽셀을 빠르게 계산해 화면을 그려준다. 
</TranslatorNote> 

쉐이더중 일부는 개발자가 직접 수정할 수 있도록 구성되어 있습니다. 따라서 기존의 기본 쉐이더를 자신만의 쉐이더로 교체할 수 있습니다. 
이렇게 하면 파이프라인 특정 부분을 더 세밀하게 제어할 수 있으며, GPU에서 실행되기 때문에 CPU의 연산 시간을 아낄 수 있습니다. 
쉐이더는 OpenGL 쉐이딩 언어 (GLSL) 로 작성되며, 다음 장에서 이를 깊이 다루게 될 것입니다. 

아래 그림은 그래픽스 파이프라인의 모든 단계를 추상적으로 나타낸 것입니다. 파란색으로 표시된 박스는 우리가 직접 쉐이더를 삽입할 수 있는 구간 입니다. 

![pipeline](./images/getting-started/pipeline.png)

보시다시피, 그래픽스 파이프라인은 정점 데이터를 완전히 렌더링된 픽셀로 변환하는 과정에서 각각 특정한 역할만 담당하는 많은 단계들로 이루어져 있습니다. 
여기서는 파이프라인이 어떻게 동작하는지에 대해 전체적인 그림을 설명하기 위해 간단히 설명하겠습니다. 

그래픽스 파이프라인 (graphics pipeline)의 입력으로는, 우리는 삼각형을 이루기 위한 3개의 3D 좌표 리스트를 넘겨줍니다. 
이 배열을 여기서는 정점 데이터 (Vertex Data) 라고 부릅니다. 정점(Vertex) 란 3D 좌표마다 주어지는 데이터 묶음을 의미합니다. 
정점의 데이터는 정점 속성(Vertex Attribute)으로 표현되며, 이 속성에는 우리가 원하는 어떤 값이든 넣을 수 있습니다. 하지만 간단히 
하기위해 이 튜토리얼 에서는 각 정점이 단지 3D 위치와 색상 값만 가진다고 가정하겠습니다. 

<Info>

OpenGL이 여러분이 넘겨준 좌표와 색상 값을 어떻게 처리해야 할지 알 수 있도록 하기 위해 , 우리는 이 데이터로 어떤 형태의 렌더링을 하고싶은지
힌트를 주어야합니다. 즉 이 데이터를 점들의 집합으로 렌더링할지 아니면 삼각형들의 집합으로 렌더링 할지, 혹은 하나의 긴 선으로 만들 수도 있겠죠?
이러한 힌트들을 `프리미티브(Primitive)` 라고 부르며 OpenGL의 그리기 명령을 호출할때 전달합니다. 그 예시로는 
`GL_POINTS` , `GL_TRIANGLES` 그리고 `GL_LINE_STRIP` 등이 있습니다. 

</Info> 

파이프라인의 첫번째 단계는 <Green>정점 쉐이더(Vertex Shader)</Green>로 , 입력으로 하나의 정점을 받습니다. 정점 쉐이더의 주요 목적은 3D 좌표를 
다른 3D 좌표로 변환하는 것입니다.(이건 나중에 더 자세히 설명하죠) 또한 정점 속성에 대한 기초적인 처리를 할 수 있습니다. 

정점 쉐이더의 단계의 출력은 선택적으로 <Green>지오메트리 쉐이더 (Geometry Shader)</Green> 로 전달될 수 있습니다. 
지오메드리 쉐이더는 입력으로 하나의 프리미티브를 이루는 정점 집합을 받고, 새로운 정점들을 내보내어 새로운 도형(프리미티브)를 생성할 수
있는 기능을 가지고 있습니다. 이 예시에서는 주어진 도형을 기반으로 두번째 삼각형을 생성합니다. 

**프리미티브 조립 단계(Primitive Assembly stage)** 는 정점 셰이더(또는 지오메트리 셰이더)에서 출력된, 하나 이상의 프리미티브를 이루는 모든 정점(만약 GL_POINTS가 선택되었다면 단일 정점)을 입력으로 받아, 주어진 프리미티브 형태에 맞게 점들을 조립합니다. 이 경우에는 두 개의 삼각형이 조립됩니다.

프리미티브 조립 단계의 출력은 <Green>레스터라이제이션 단계(rasterization state)</Green>으로 넘어가 프리미티브 결과들을 화면에 대응하는 
픽셀들로 변환합니다. 이는 프래그먼트(fragments)가 되어 프래그먼트 쉐이더(fragment shader)가 사용할 수 있도록 합니다. 
프래그먼트 쉐이더가 돌아가기 전에 <Green>클리핑(cliping)</Green>이 수행됩니다. 클리핑은 모든 화면 밖에 위치한 모든 프래그먼트를 제거하여 
성능을 향상 시킵니다. 


<Info>
프래그먼트(fragment)란 OpenGL이 하나의 픽셀을 생성(렌더)하기 위한 모든 데이터를 일컫습니다. 
</Info>

<Green>프래그먼트 쉐이더(fragment shader)</Green>의 주요 목적은 최종적인 픽셀의 색상을 계산하는 것입니다. 보통 이 단계에서 
OpenGL의 고급 효과들이 대부분 발생합니다. 일반적으로 프래그먼트 쉐이더는 최종 픽셀 색상을 계산하는 데 사용할 수 있는 
3D장면에 대한 데이터(예: 빛 , 그림자, 광원의 색상 등)을 포함합니다. 


모든 픽셀에 대한 색상값이 계산된 후, 최종 객체는 알파 테스트와 블랜딩 (Alpha Test & Blending) 단계라고 불리는 한단계를 더 거칩니다. 
이 단계에서는 프래그먼트의 깊이(Depth) 와 스텐실 (Stencil) 값 (이에 대해서는 나중에 다룹니다)을 검사하여, 해당 프래그먼트가 
다른 객체들 보다 앞에 있는지 뒤에 있는지를 확인하고, 필요하다면 버려집니다. 또한 이 단계에서는 알파 값(알파 값은 객체의 불투명도를 정의함)을 
확인하고 여러 객체를 이에 따라 섞어 표시합니다. 따라서 프레그먼트 쉐이더에서 어떤 픽셀의 출력 색상이 계산되었더라도, 여러 삼각형이
동시에 렌더링 되는 상황에서는 최종적으로 화면에 표시되는 픽셀 색상이 완전히 달라질 수도 있습니다. 

보시다시피 그래픽스 파이프라인은 꽤 복잡하며 다양한 설정 가능한 부분들을 포함하고 있습니다. 하지만 대부분의 경우 우리는 
정점 쉐이더(Vertex Shader)와 프래그먼트 쉐이더(Fragment Shader)만 다루면 됩니다. 지오메트리 쉐이더(Geometry shader)는 선택 사항이며
보통 기본 상태로 둡니다. 또한 여기서는 다루지 않았지만 테셀레이션(Tessellation) 단계와 트랜스폼 피드백 루프(Transform Feedback Loop) 같은
기능도 존재합니다. 

현대 OpenGL에서는 반드시 사용자가 직접 정의한 정점 쉐이더와 프레그먼트 쉐이더르 작성해야 합니다. (GPU에서는 기본 제공되는 정점/프래그먼트 쉐이더가 없습니다)
이 때문에 현대 OpenGL을 처음 배우기가 어렵습니다. 삼각형 하나를 만들때에도 꽤 많은 지식이 필요하기 때문입니다. 
하지만 이번장의 끝에서 삼각형을 직접 만들어보면, 그래픽스 프로그래밍에 대해 훨씬더 많은 것을 알게 될 것입니다. 


<TranslatorNote type="clarification" author="이도경" >
간단한 정리 삼각형을 그리기 위해서 

<NumberedList>
<NumberedItem>**정점 데이터**: 삼각형의 꼭짓점 3개의 좌표와 색깔을 준비한다.(예, 왼쪽 위 빨강, 오른쪽 위 초록, 아래 파랑)</NumberedItem>
<NumberedItem>**정점 쉐이더**: 이 좌표들을 화면 안에서 어디에 그릴지 계산해 준다. (3D 공간 좌표 -> 화면에 보이기 위한 2D 좌표로 변환)</NumberedItem>
<NumberedItem>**프리미티브 조립**: 꼭짓점들을 이어서 삼각형 모양을 만든다.</NumberedItem>
<NumberedItem>**레스터화**: 삼각형 안을 픽셀 단위로 잘게 쪼개서 "이곳을 색칠해야지" 하고 색칠될 픽셀 후보(프래그먼트)들을 만든다. (예: 마치 삼각형 안을 색연필로 칠할 칸을 잘게 나누는 것처럼)</NumberedItem>
<NumberedItem>**프래그먼트 쉐이더**: 각 픽셀 후보마다 "어떤 색으로 칠하지?" 를 결정한다.</NumberedItem>
<NumberedItem>**테스트 & 블렌딩**: 계산된 픽셀이 다른 물체 앞에 있으면 남기고, 뒤에있으면 지우는 작업 또 유리 같은 건 투명도 값을 이용해서 섞어준다.</NumberedItem>
<NumberedItem>**최종화면 출력**: 픽셀들이 다 색칠되어 삼각형 완성!</NumberedItem>
</NumberedList>
</TranslatorNote> 


## Vertex input (정점 입력)

무언가를 그리기 시작하기 위해 우리는 우선  OpenGL에게 정점 데이터(vertex data)를 줍니다다. OpenGL은 3D 그래픽 라이브러리 이기 때문에 
모든 OpenGL에서 우리가 특정하는 좌표들은 3D 형태입니다. (x,y그리고 z 좌표) OpenGL은 단순히 모든 3D좌표를 화면의 2D 픽셀로 변환하지 않습니다.
OpenGL은 오직 특정한 범위 안에 있는 3D좌표만 처리합니다. 이 범위란 x,y,z 모든 축에서 -1.0 ~ 1.0 사이인데 이를 **정규화 장치 좌표(Normalized Device Coordinateds, NDC)**
라고 부릅니다. 이 범위 안에 있는 좌표들만 화면에 보이게 되고, 이 범위를 벗어난 좌표들은 화면에 보이지 않습니다. 

우리는 삼각형 하나를 그리려고 하므로, 총 세개의 정점을 지정해야합니다. 각 정점은 3D위치를 가져야하고, 이를 OpenGL의 가시 영역인 
정규화 장치 좌표 (NDC) 범위 안에서 float 배열로 정의합니다. 

```cpp

float vertices[] = {
    -0.5f, -0.5f, 0.0f,
     0.5f, -0.5f, 0.0f,
     0.0f,  0.5f, 0.0f
};  
```

OpenGL은 3D공간이므로 우리는 2D 공간에 그려질 삼각형의 z 좌표를 모두 0.0으로 그립니다. 
이것은 삼각형의 깊이(Depth)를 모두 똑같도록 만들고 2D 삼각형 처럼 보이게 할 것입니다. 


<Info>
#### Normalized Device Coordinates : 정규화 장치 좌표 (NDC)

정점 좌표가 정점 쉐이더에서 처리되고 나면, 그것들은 정규화 장치 좌표라는 작은 공간안에 있게 됩니다. 이 좌표계에서는 x,y,z값이 모두
-1.0 ~ 1.0 범위 안에 있습니다. 만약 어떤 좌표가 이 범위를 벗어나면 해당 좌표는 잘려서 화면에 보이지 않게 됩니다. 
아래 그림은 우리가 지정한 삼각형을 정규화 장치 좌표 (NDC) 안에 표시한 예시입니다. (Z축은 무시)
![ndc](./images/getting-started/ndc.png)

보통의 화면 좌표와는 달리 , 이 좌표계에서는 Y축이 위쪽 방향이 양수이고 (0.0) 좌표는 화면의 왼쪽 위가 아니라 
정중앙에 있습니다. 결국 모든 좌표는 이 정규화 장치 좌표 공간안에 들어와야 화면에 보일 수 있습니다. 

정규화 장치 좌표(NDC)로 변환된 좌표들은 이후에 우리가 <Func 
  name="glViewport"
  params='[{"name":"x","type":"GLint","description":"뷰포트 사각형의 왼쪽 x좌표입니다. 윈도우 내 위치를 픽셀 기준으로 설정합니다."},{"name":"y","type":"GLint","description":"뷰포트 사각형의 아래쪽 y좌표입니다. OpenGL에서는 y=0이 윈도우의 하단을 의미합니다."},{"name":"width","type":"GLsizei","description":"뷰포트의 가로 너비를 지정합니다."},{"name":"height","type":"GLsizei","description":"뷰포트의 세로 높이를 지정합니다."}]'
  description="이 함수는 OpenGL 렌더링을 위한 실제 윈도우 내 렌더링 영역(뷰포트)을 설정합니다. 뷰포트는 정규화 장치 좌표(-1 ~ 1 범위)를 윈도우 좌표로 매핑하는 기준이 됩니다. 지정된 좌표를 통해 OpenGL이 데이터를 창 내 어느 영역에 표시할지 결정합니다."
  example="glViewport(0, 0, 800, 600);"
  tags='["Initialization"]'
/> 함수로 지정한 데이터를 이용해 뷰포트 변환(Viewport Transform)을 거쳐 스크린 좌표(Screen-space coordinates)로 변환됩니다. 
이렇게 변환된 화면 좌표들은 다시 프래그먼트 쉐이더(Fragment Shader)의 입력으로 들어가는 프래그먼트(Fragment)들로 나뉘게 됩니다. 

</Info> 



