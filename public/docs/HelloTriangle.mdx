# Hello Triangle 

OpenGL 에서 모든 것은 3D 공간속에 있습니다다. 하지만 화면이나 윈도우는 2D 픽셀 배열이기 때문에 
OpenGL의 많은 부분은 모든 3D 좌표들을 2D 픽셀로 변형하여 스크린에 맞도록 하는 것입니다. 
3D좌표를 2D 픽셀로 변형하는 것은 OpenGL의 <Green>graphics pipeline(그래픽스 파이프라인)</Green>이 맡게됩니니다. 
graphics pipeline은 두개의 큰 부분으로 나뉠 수 있습니다.  

<NumberedList>
<NumberedItem>첫번째 부분은 3D 좌표를 2D 좌표로 변환하는 과정</NumberedItem>
<NumberedItem>두번째 부분은 2D 좌표를 실제 색이 있는 픽셀로 변환하는 과정입니다.</NumberedItem>
</NumberedList> 

이번 장에서는 그래픽스 파이프라인을 간단히 살펴보고, 우리가 멋진 픽셀들을 만들기 위해 이를 어떻게
활용할 수 있는지 알아보겠습니다. 

그래픽스 파이프라인은 입력으로 일련의 3D 좌표를 받아들이고, 이를 화면의 색이 있는 2D 픽셀로 변환합니다. 
그래픽스 파이프라인은 여러 단계로 나눌 수 있으며, 각 단계는 이전 단계의 출력을 입력으로 받아야합니다. 
이 모든 단계는 매우 전문화 되어있고 (하나의 특정한 기능만 처리합니다.) 
쉽게 병렬적으로 처리 될 수 있습니다. 이것들의 병렬적인 성질때문에 오늘날의 그래픽 카드에는 수천 개의 작은 처리 코어가 존재하여 데이터를
파이프라인 안에서 빠르게 처리할 수 있습니다. 
이러한 처리 코어들은 파이프라인의 각 단계에서 실행되는 작은 프로그램을 구동합니다. 이 작은 프로그램들을 쉐이더(shader) 라고 부릅니다.

<TranslatorNote type="clarification" author="이도경" collapsible={true} defaultOpen={false}>
GPU 코어 
- CPU는 몇 개의 코어를 차례차례 계산
- GPU는 단순한 코어를 수천개나 넣어서 계산을 동시에 처리 

따라서 화면에 있는 수많은 점 픽셀을 한꺼 번에 처리할 수 있다. 


쉐이더 (Shader) = 작은 프로그램
- GPU 코어가 실행하는 짧은 코드 조각 이 코드가 정점 하나당 1번, 픽셀 하나당 1번 실행 된다. 


GPU는 수천개의 작은 코어로 쉐이더라는 짧은 프로그램을 동시에 실행해서, 수많은 점과 픽셀을 빠르게 계산해 화면을 그려준다. 
</TranslatorNote> 

쉐이더중 일부는 개발자가 직접 수정할 수 있도록 구성되어 있습니다. 따라서 기존의 기본 쉐이더를 자신만의 쉐이더로 교체할 수 있습니다. 
이렇게 하면 파이프라인 특정 부분을 더 세밀하게 제어할 수 있으며, GPU에서 실행되기 때문에 CPU의 연산 시간을 아낄 수 있습니다. 
쉐이더는 OpenGL 쉐이딩 언어 (GLSL) 로 작성되며, 다음 장에서 이를 깊이 다루게 될 것입니다. 

아래 그림은 그래픽스 파이프라인의 모든 단계를 추상적으로 나타낸 것입니다. 파란색으로 표시된 박스는 우리가 직접 쉐이더를 삽입할 수 있는 구간 입니다. 

![pipeline](./images/getting-started/pipeline.png)

보시다시피, 그래픽스 파이프라인은 정점 데이터를 완전히 렌더링된 픽셀로 변환하는 과정에서 각각 특정한 역할만 담당하는 많은 단계들로 이루어져 있습니다. 
여기서는 파이프라인이 어떻게 동작하는지에 대해 전체적인 그림을 설명하기 위해 간단히 설명하겠습니다. 

그래픽스 파이프라인 (graphics pipeline)의 입력으로는, 우리는 삼각형을 이루기 위한 3개의 3D 좌표 리스트를 넘겨줍니다. 
이 배열을 여기서는 정점 데이터 (Vertex Data) 라고 부릅니다. 정점(Vertex) 란 3D 좌표마다 주어지는 데이터 묶음을 의미합니다. 
정점의 데이터는 정점 속성(Vertex Attribute)으로 표현되며, 이 속성에는 우리가 원하는 어떤 값이든 넣을 수 있습니다. 하지만 간단히 
하기위해 이 튜토리얼 에서는 각 정점이 단지 3D 위치와 색상 값만 가진다고 가정하겠습니다. 

<Info>

OpenGL이 여러분이 넘겨준 좌표와 색상 값을 어떻게 처리해야 할지 알 수 있도록 하기 위해 , 우리는 이 데이터로 어떤 형태의 렌더링을 하고싶은지
힌트를 주어야합니다. 즉 이 데이터를 점들의 집합으로 렌더링할지 아니면 삼각형들의 집합으로 렌더링 할지, 혹은 하나의 긴 선으로 만들 수도 있겠죠?
이러한 힌트들을 `프리미티브(Primitive)` 라고 부르며 OpenGL의 그리기 명령을 호출할때 전달합니다. 그 예시로는 
`GL_POINTS` , `GL_TRIANGLES` 그리고 `GL_LINE_STRIP` 등이 있습니다. 

</Info> 

파이프라인의 첫번째 단계는 <Green>정점 쉐이더(Vertex Shader)</Green>로 , 입력으로 하나의 정점을 받습니다. 정점 쉐이더의 주요 목적은 3D 좌표를 
다른 3D 좌표로 변환하는 것입니다.(이건 나중에 더 자세히 설명하죠) 또한 정점 속성에 대한 기초적인 처리를 할 수 있습니다. 

정점 쉐이더의 단계의 출력은 선택적으로 <Green>지오메트리 쉐이더 (Geometry Shader)</Green> 로 전달될 수 있습니다. 
지오메드리 쉐이더는 입력으로 하나의 프리미티브를 이루는 정점 집합을 받고, 새로운 정점들을 내보내어 새로운 도형(프리미티브)를 생성할 수
있는 기능을 가지고 있습니다. 이 예시에서는 주어진 도형을 기반으로 두번째 삼각형을 생성합니다. 

**프리미티브 조립 단계(Primitive Assembly stage)** 는 정점 셰이더(또는 지오메트리 셰이더)에서 출력된, 하나 이상의 프리미티브를 이루는 모든 정점(만약 GL_POINTS가 선택되었다면 단일 정점)을 입력으로 받아, 주어진 프리미티브 형태에 맞게 점들을 조립합니다. 이 경우에는 두 개의 삼각형이 조립됩니다.

프리미티브 조립 단계의 출력은 <Green>레스터라이제이션 단계(rasterization state)</Green>으로 넘어가 프리미티브 결과들을 화면에 대응하는 
픽셀들로 변환합니다. 이는 프래그먼트(fragments)가 되어 프래그먼트 쉐이더(fragment shader)가 사용할 수 있도록 합니다. 
프래그먼트 쉐이더가 돌아가기 전에 <Green>클리핑(cliping)</Green>이 수행됩니다. 클리핑은 모든 화면 밖에 위치한 모든 프래그먼트를 제거하여 
성능을 향상 시킵니다. 


<Info>
프래그먼트(fragment)란 OpenGL이 하나의 픽셀을 생성(렌더)하기 위한 모든 데이터를 일컫습니다. 
</Info>

<Green>프래그먼트 쉐이더(fragment shader)</Green>의 주요 목적은 최종적인 픽셀의 색상을 계산하는 것입니다. 보통 이 단계에서 
OpenGL의 고급 효과들이 대부분 발생합니다. 일반적으로 프래그먼트 쉐이더는 최종 픽셀 색상을 계산하는 데 사용할 수 있는 
3D장면에 대한 데이터(예: 빛 , 그림자, 광원의 색상 등)을 포함합니다. 


모든 픽셀에 대한 색상값이 계산된 후, 최종 객체는 알파 테스트와 블랜딩 (Alpha Test & Blending) 단계라고 불리는 한단계를 더 거칩니다. 
이 단계에서는 프래그먼트의 깊이(Depth) 와 스텐실 (Stencil) 값 (이에 대해서는 나중에 다룹니다)을 검사하여, 해당 프래그먼트가 
다른 객체들 보다 앞에 있는지 뒤에 있는지를 확인하고, 필요하다면 버려집니다. 또한 이 단계에서는 알파 값(알파 값은 객체의 불투명도를 정의함)을 
확인하고 여러 객체를 이에 따라 섞어 표시합니다. 따라서 프레그먼트 쉐이더에서 어떤 픽셀의 출력 색상이 계산되었더라도, 여러 삼각형이
동시에 렌더링 되는 상황에서는 최종적으로 화면에 표시되는 픽셀 색상이 완전히 달라질 수도 있습니다. 

보시다시피 그래픽스 파이프라인은 꽤 복잡하며 다양한 설정 가능한 부분들을 포함하고 있습니다. 하지만 대부분의 경우 우리는 
정점 쉐이더(Vertex Shader)와 프래그먼트 쉐이더(Fragment Shader)만 다루면 됩니다. 지오메트리 쉐이더(Geometry shader)는 선택 사항이며
보통 기본 상태로 둡니다. 또한 여기서는 다루지 않았지만 테셀레이션(Tessellation) 단계와 트랜스폼 피드백 루프(Transform Feedback Loop) 같은
기능도 존재합니다. 

현대 OpenGL에서는 반드시 사용자가 직접 정의한 정점 쉐이더와 프레그먼트 쉐이더르 작성해야 합니다. (GPU에서는 기본 제공되는 정점/프래그먼트 쉐이더가 없습니다)
이 때문에 현대 OpenGL을 처음 배우기가 어렵습니다. 삼각형 하나를 만들때에도 꽤 많은 지식이 필요하기 때문입니다. 
하지만 이번장의 끝에서 삼각형을 직접 만들어보면, 그래픽스 프로그래밍에 대해 훨씬더 많은 것을 알게 될 것입니다. 


<TranslatorNote type="clarification" author="이도경" collapsible={true} defaultOpen={false}>
간단한 정리 삼각형을 그리기 위해서 

<NumberedList>
<NumberedItem>**정점 데이터**: 삼각형의 꼭짓점 3개의 좌표와 색깔을 준비한다.(예, 왼쪽 위 빨강, 오른쪽 위 초록, 아래 파랑)</NumberedItem>
<NumberedItem>**정점 쉐이더**: 이 좌표들을 화면 안에서 어디에 그릴지 계산해 준다. (3D 공간 좌표 -> 화면에 보이기 위한 2D 좌표로 변환)</NumberedItem>
<NumberedItem>**프리미티브 조립**: 꼭짓점들을 이어서 삼각형 모양을 만든다.</NumberedItem>
<NumberedItem>**레스터화**: 삼각형 안을 픽셀 단위로 잘게 쪼개서 "이곳을 색칠해야지" 하고 색칠될 픽셀 후보(프래그먼트)들을 만든다. (예: 마치 삼각형 안을 색연필로 칠할 칸을 잘게 나누는 것처럼)</NumberedItem>
<NumberedItem>**프래그먼트 쉐이더**: 각 픽셀 후보마다 "어떤 색으로 칠하지?" 를 결정한다.</NumberedItem>
<NumberedItem>**테스트 & 블렌딩**: 계산된 픽셀이 다른 물체 앞에 있으면 남기고, 뒤에있으면 지우는 작업 또 유리 같은 건 투명도 값을 이용해서 섞어준다.</NumberedItem>
<NumberedItem>**최종화면 출력**: 픽셀들이 다 색칠되어 삼각형 완성!</NumberedItem>
</NumberedList>
</TranslatorNote> 


## Vertex input (정점 입력)

무언가를 그리기 시작하기 위해 우리는 우선  OpenGL에게 정점 데이터(vertex data)를 줍니다다. OpenGL은 3D 그래픽 라이브러리 이기 때문에 
모든 OpenGL에서 우리가 특정하는 좌표들은 3D 형태입니다. (x,y그리고 z 좌표) OpenGL은 단순히 모든 3D좌표를 화면의 2D 픽셀로 변환하지 않습니다.
OpenGL은 오직 특정한 범위 안에 있는 3D좌표만 처리합니다. 이 범위란 x,y,z 모든 축에서 -1.0 ~ 1.0 사이인데 이를 **정규화 장치 좌표(Normalized Device Coordinateds, NDC)**
라고 부릅니다. 이 범위 안에 있는 좌표들만 화면에 보이게 되고, 이 범위를 벗어난 좌표들은 화면에 보이지 않습니다. 

우리는 삼각형 하나를 그리려고 하므로, 총 세개의 정점을 지정해야합니다. 각 정점은 3D위치를 가져야하고, 이를 OpenGL의 가시 영역인 
정규화 장치 좌표 (NDC) 범위 안에서 float 배열로 정의합니다. 

```cpp

float vertices[] = {
    -0.5f, -0.5f, 0.0f,
     0.5f, -0.5f, 0.0f,
     0.0f,  0.5f, 0.0f
};  
```

OpenGL은 3D공간이므로 우리는 2D 공간에 그려질 삼각형의 z 좌표를 모두 0.0으로 그립니다. 
이것은 삼각형의 깊이(Depth)를 모두 똑같도록 만들고 2D 삼각형 처럼 보이게 할 것입니다. 


<Info>
#### Normalized Device Coordinates : 정규화 장치 좌표 (NDC)

정점 좌표가 정점 쉐이더에서 처리되고 나면, 그것들은 정규화 장치 좌표라는 작은 공간안에 있게 됩니다. 이 좌표계에서는 x,y,z값이 모두
-1.0 ~ 1.0 범위 안에 있습니다. 만약 어떤 좌표가 이 범위를 벗어나면 해당 좌표는 잘려서 화면에 보이지 않게 됩니다. 
아래 그림은 우리가 지정한 삼각형을 정규화 장치 좌표 (NDC) 안에 표시한 예시입니다. (Z축은 무시)
![ndc](./images/getting-started/ndc.png)

보통의 화면 좌표와는 달리 , 이 좌표계에서는 Y축이 위쪽 방향이 양수이고 (0.0) 좌표는 화면의 왼쪽 위가 아니라 
정중앙에 있습니다. 결국 모든 좌표는 이 정규화 장치 좌표 공간안에 들어와야 화면에 보일 수 있습니다. 

정규화 장치 좌표(NDC)로 변환된 좌표들은 이후에 우리가 <Func 
  name="glViewport"
  params='[{"name":"x","type":"GLint","description":"뷰포트 사각형의 왼쪽 x좌표입니다. 윈도우 내 위치를 픽셀 기준으로 설정합니다."},{"name":"y","type":"GLint","description":"뷰포트 사각형의 아래쪽 y좌표입니다. OpenGL에서는 y=0이 윈도우의 하단을 의미합니다."},{"name":"width","type":"GLsizei","description":"뷰포트의 가로 너비를 지정합니다."},{"name":"height","type":"GLsizei","description":"뷰포트의 세로 높이를 지정합니다."}]'
  description="이 함수는 OpenGL 렌더링을 위한 실제 윈도우 내 렌더링 영역(뷰포트)을 설정합니다. 뷰포트는 정규화 장치 좌표(-1 ~ 1 범위)를 윈도우 좌표로 매핑하는 기준이 됩니다. 지정된 좌표를 통해 OpenGL이 데이터를 창 내 어느 영역에 표시할지 결정합니다."
  example="glViewport(0, 0, 800, 600);"
  tags='["Initialization"]'
/> 함수로 지정한 데이터를 이용해 뷰포트 변환(Viewport Transform)을 거쳐 스크린 좌표(Screen-space coordinates)로 변환됩니다. 
이렇게 변환된 화면 좌표들은 다시 프래그먼트 쉐이더(Fragment Shader)의 입력으로 들어가는 프래그먼트(Fragment)들로 나뉘게 됩니다. 

</Info> 

정점 데이터를 정의했으니 이제 이것을 그래픽스 파이프라인의 첫 번째 단계인 **정점 셰이더(Vertex Shader)** 에 
입력으로 보내고 싶습니다. 
이 작업은 GPU 메모리에 정점 데이터를 저장할 메모리를 만들고,
OpenGL이 그 메모리를 어떻게 해석해야 하는지 설정하며,
데이터를 그래픽 카드로 어떻게 보낼지를 지정하는 과정을 통해 이루어집니다. 
그 후 정점 셰이더는 우리가 지시한 만큼의 정점을 해당 메모리에서 가져와 처리하게 됩니다.

이 메모리들을 위리는 정점 버퍼 객체(Vertex Buffer Objects : VBO)로 관리하게 됩니다. 
VBO는 대량의 정점들을 GPU 메모리에 저장할 수 있게 해줍니다. 
이러한 버퍼 객체를 사용하는 것의 장점은 정점을 하나씩 GPU로 보내지 않고 큰 덩어리의 데이터들을 한번에 그래픽스 카드로 보낼 수 있게 해줍니다. 
만약 충분한 메모리가 남아있으면 여기에 저장할 수도 있습니다. 
CPU에서 GPU(Graphics Card)로 데이터를 보내는 작업은 상대적으로 느리기 때문에, 가능하다면 많은 데이터를 한번에 보내는게 좋겠죠 
데이터가 GPU메모리에 전달되고 나면 정점 쉐이더는 거의 즉시 모든 정점들에 매우 빠르게 접근할 수 있습니다. 

VBO는 우리가 OpenGL 소개 장에서 언급했던 OpenGL 객체의 거의 첫 등장입니다. OpenGL의 다른 객체들과 마찬가지로 
버퍼에도 고유한 ID가 부여됩니다. 따라서 
<Func 
  name="glGenBuffers"
  params='[{"name":"n","type":"GLsizei","description":"생성할 버퍼 객체의 개수입니다."},{"name":"buffers","type":"GLuint*","description":"생성된 버퍼 객체의 ID들이 저장될 배열의 포인터입니다."}]'
  description="OpenGL에서 하나 또는 여러 개의 버퍼 객체를 생성합니다. 버퍼 객체는 정점 데이터, 인덱스 데이터 등을 GPU 메모리에 저장하기 위해 사용됩니다. 생성된 각 버퍼 객체에는 고유한 ID가 부여되며, 이 ID를 통해 해당 버퍼를 참조할 수 있습니다."
  example="GLuint VBO; // 버퍼 ID를 저장할 변수\nglGenBuffers(1, &VBO); // 1개의 버퍼 생성\n\n// 여러 개 생성하는 경우\nGLuint buffers[3];\nglGenBuffers(3, buffers); // 3개의 버퍼 생성"
  tags='["Buffer Management", "OpenGL Objects"]'
/> 를 사용해 버퍼 ID를 생성할 수 있습니다. 

```cpp
unsigned int VBO;
glGenBuffers(1, &VBO);  
```


<Collapsible title="OpenGL 객체" variant="info">

### OpenGL 에서의 객체란

OpenGL에서 객체란 OpenGL 상태의 일부분을 대표하는 설정값들의 집합입니다. 
예를 들어, 하나의 객체는 그리기 창(window)의 설정을 나타낼 수 있으며 
이 객체에는 창의 크기, 색상 수, 이름 등 다양한 옵션션을 설정할 수 있습니다. 

### 객체의 장점 

OpenGL에서 객체를 사용하면 여러 개의 객체를 만들어 따로따로 설정할 수 있고,
작업 시점에 맞춰 원하는 객체를 필요할 때마다 바인딩하여 사용할 수 있습니다.

예를 들어: 3D 모델 객체를 각각 하나의 OpenGL 객체로 만들 수 있습니다. (예: 집, 캐릭터 등) 미리 설정해 둔 각 객체를 그릴 때마다 바인딩만 하면 되고,
다시 설정을 반복하지 않아도 됩니다.

</Collapsible>


<TranslatorNote type="clarification" author="이도경" collapsible={true} defaultOpen={false}>

#### OpenGL에서 오브젝트 = 객체 (Object)란?
OpenGL은 화면에 뭔가를 그릴때 GPU안에 여러 자원을 만들어서 관리합니다. 
이 자원들을 오브젝트(Object)라고 부릅니다.  

#### 왜 ID가 필요할까?
OpenGL은 C 함수 기반이라서 객체를 직접 다루지 못합니다. (객체지향 언어가 아니기 때문에 클래스/객체 형태로 다루지 못합니다. 
대신 함수와 정수 ID로 자원을 관리합니다.)
그래서 GPU에 뭔가를 만들면 OpenGL은 그걸 가리키는 숫자 ID를 줍니다. (마치 주민등록 번호 처럼 번호 = GPU 메모리 자원 으로 연결되죠)
나중에 이 ID를 다시 불러와서 (glBindBuffer) 쓰면 , GPU가 그 자원을 찾아서 사용합니다. 

#### VBO의 경우 
VBO = 정점 데이터를 담는 GPU 메모리 상자 
VBO를 하나 만들어 달라 요청하면 OpenGL이 GPU에 VBO 공간을 만들고 그걸 가리키는 ID를 돌려주는 것입니다. 
그 ID 변수를 저장해 두었다가 이후에 데이터 넣기/바인딩/삭제 같은 작업을 합니다.


</TranslatorNote> 


OpenGL은 많은 타입의 버퍼 오브젝트(객체)를 가지고 있습니다. 그중 정점 버퍼의 오브젝트 타입은 <Blue>GL_ARRAY_BUFFER</Blue> 입니다. 
OpenGL은 우리가 여러 버퍼들을 그들 각자의 타입만 다르다면 한번에 바인딩 할 수 있게 해줍니다. 
우리는 새롭게 생성된 버퍼를 <Blue>GL_ARRAY_BUFFER</Blue> 타겟으로 전달해 줄수 있습니다. 바로 <Func 
  name="glBindBuffer"
  params='[{"name":"target","type":"GLenum","description":"바인딩할 버퍼의 타입을 지정합니다. 가장 일반적인 것은 GL_ARRAY_BUFFER와 GL_ELEMENT_ARRAY_BUFFER입니다."},{"name":"buffer","type":"GLuint","description":"바인딩할 버퍼 객체의 ID입니다. 0을 전달하면 현재 바인딩된 버퍼를 해제합니다."}]'
  description="버퍼 객체를 현재 버퍼 타입 타겟에 바인딩합니다. 한 번에 각 버퍼 타입당 하나의 버퍼만 바인딩될 수 있습니다. 버퍼를 바인딩하면 해당 타입에 대한 모든 후속 버퍼 작업이 현재 바인딩된 버퍼에 적용됩니다."
  example="glBindBuffer(GL_ARRAY_BUFFER, VBO);\n// 이제 GL_ARRAY_BUFFER 타겟에 대한 모든 작업이 VBO에 적용됩니다\n\n// 바인딩 해제\nglBindBuffer(GL_ARRAY_BUFFER, 0);"
  tags='["Buffer Management", "OpenGL State"]'
/> 함수를 사용해서 말이죠.

```cpp
glBindBuffer(GL_ARRAY_BUFFER, VBO);  
```

이 시점부터 우리가 만드는 어떤 <Blue>GL_ARRAY_BUFFER</Blue> 타깃에 대해 호출하는 모든 버퍼 관련 함수는 현재 바인딩된 버퍼(VBO)
를 설정하게 됩니다. 그 다음 <Func 
  name="glBufferData"
  params='[{"name":"target","type":"GLenum","description":"버퍼 객체의 타겟을 지정합니다. 가장 일반적인 것은 GL_ARRAY_BUFFER와 GL_ELEMENT_ARRAY_BUFFER입니다."},{"name":"size","type":"GLsizeiptr","description":"버퍼 객체의 새로운 데이터 저장소 크기를 바이트 단위로 지정합니다."},{"name":"data","type":"const GLvoid*","description":"버퍼로 복사될 데이터에 대한 포인터입니다. NULL이면 할당된 메모리를 비워둡니다."},{"name":"usage","type":"GLenum","description":"데이터의 예상 사용 패턴입니다. 가장 일반적인 것은 GL_STATIC_DRAW, GL_DYNAMIC_DRAW, GL_STREAM_DRAW입니다."}]'
  description="현재 바인딩된 버퍼 객체에 메모리를 할당하고 데이터를 저장합니다. 버퍼 객체를 추가/편집하는 여러 함수 중 하나입니다. 이 함수는 이전에 할당된 데이터를 새로운 데이터로 대체합니다."
  example="GLfloat vertices[] = {\n    0.0f,  0.5f, 0.0f,\n   -0.5f, -0.5f, 0.0f,\n    0.5f, -0.5f, 0.0f\n};\nglBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW);"
  tags='["Buffer Management", "Data Upload"]'
  /> 함수를 호출해서 미리 정의한 정점 배열을 현재 바인딩된 버퍼의 메모리로 복사합니다.

```cpp

glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW);
```
<Func 
  name="glBufferData"
  params='[{"name":"target","type":"GLenum","description":"버퍼 객체의 타겟을 지정합니다. 가장 일반적인 것은 GL_ARRAY_BUFFER와 GL_ELEMENT_ARRAY_BUFFER입니다."},{"name":"size","type":"GLsizeiptr","description":"버퍼 객체의 새로운 데이터 저장소 크기를 바이트 단위로 지정합니다."},{"name":"data","type":"const GLvoid*","description":"버퍼로 복사될 데이터에 대한 포인터입니다. NULL이면 할당된 메모리를 비워둡니다."},{"name":"usage","type":"GLenum","description":"데이터의 예상 사용 패턴입니다. 가장 일반적인 것은 GL_STATIC_DRAW, GL_DYNAMIC_DRAW, GL_STREAM_DRAW입니다."}]'
  description="현재 바인딩된 버퍼 객체에 메모리를 할당하고 데이터를 저장합니다. 버퍼 객체를 추가/편집하는 여러 함수 중 하나입니다. 이 함수는 이전에 할당된 데이터를 새로운 데이터로 대체합니다."
  example="GLfloat vertices[] = {\n    0.0f,  0.5f, 0.0f,\n   -0.5f, -0.5f, 0.0f,\n    0.5f, -0.5f, 0.0f\n};\nglBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW);"
  tags='["Buffer Management", "Data Upload"]'
/> 는 사용자 정의 데이터를 현재 바인딩된 버퍼에 복사하는 데 특화된 함수입니다. 
<NumberedList>
<NumberedItem>**첫번째 인자**: 우리가 데이터를 복사하려는 버퍼의 타입을 지정합니다. 여기서는 GL_ARRAY_BUFFER 타깃에 현재 바인딩된 정점 버퍼(VBO)입니다.</NumberedItem>
<NumberedItem>**두번째 인자**: 버퍼에 전달할 데이터의 크기(바이트 단위)를 지정합니다. 보통 정점 데이터의 sizeof을 사용하면 충분합니다.</NumberedItem>
<NumberedItem>**세번째 인자**: 우리가 실제로 전송하려는 데이터입니다.</NumberedItem>
<NumberedItem>**네번째 인자**: 그래픽 카드가 주어진 데이터를 어떻게 관리해야하는지를 지정합니다. 이 값은 3가지 형태가 있습니다.</NumberedItem>
</NumberedList> 

- <Blue>GL_STREAM_DRAW</Blue>: 데이터를 한 번만 설정하고, GPU에서 많아야 몇 번만 사용합니다.
- <Blue>GL_STATIC_DRAW</Blue>: 데이터를 한 번만 설정하고 여러 번 사용합니다.
- <Blue>GL_DYNAMIC_DRAW</Blue>: 데이터를 자주 변경하면서 여러 번 사용합니다.

삼각형의 위치 데이터는 변하지 않고, 많이 사용되며, 모든 렌더 호출마다 동일하게 유지되므로 <Blue>GL_STATIC_DRAW</Blue>를 사용하는 것이
가장 적합합니다. 반대로 데이터가 자주 변경될 가능성이 있는 버퍼라면, <Blue>GL_DYNAMIC_DRAW</Blue>를 사용하면 그래픽 카드가 더 빠른 쓰기가 가능한
메모리에 데이터를 배치하도록 보장합니다.

지금까지 우리는 VBO(정점 버퍼 객체)가 관리하는 그래픽 카드 메모리에 정점 데이터를 저장했습니다.
이제 이 데이터를 실제로 처리할 정점 쉐이더와 프래그먼트 쉐이더를 만들어야 하므로 다음 단계로 넘어가겠습니다. 

## Vertex shader 
정점 쉐이더(Vertex Shader)는 우리 같은 개발자가 직접 프로그래밍할 수 있는 쉐이더 중 하나입니다. 
현대 OpenGL에서는 렌더링을 하려면 최소한 정점 쉐이더와 프래그먼트 쉐이더를 반드시 설정해야 합니다. 
따라서 우리는 간단히 쉐이더를 소개하고 첫번째 삼각형을 그리기 위해 아주 간단한 두 개의 쉐이더를 설정해 보겠습니다. 
쉐이더에 대한 자세한 내용은 다음 장에서 더 깊이 다룰 것입니다. 

우리가 해야할 첫번째 일은 GLSL(OpenGL Shading Language)로 정점 쉐이더를 작성한 뒤 , 이 쉐이더를 컴파일하여 
애플리케이션에서 사용할 수 있도록 하는 것입니다. 아래에는 GLSL로 작성된 아주 기본적인 정점 쉐이더의 소스코드가 나와 있습니다. 

```cpp

#version 330 core
layout (location = 0) in vec3 aPos;

void main()
{
    gl_Position = vec4(aPos.x, aPos.y, aPos.z, 1.0);
}
```

보시다시피 GLSL은 C언어와 유사합니다. 각각의 쉐이더는 버전 선언으로 시작됩니다. 
OpenGL 3.3 이상부터는 GLSL의 버전 번호가 OpenGL의 버전과 일치합니다. 
(GLSL 버전 420은 OpenGL 4.2에 해당) 
우리는 또한 명시적으로 코어 프로파일(core profile)을 사용한다고 선언합니다. 

그 다음, 정점 쉐이더 에서는 `in` 키워드를 사용해 입력 정점 속성(Vertex Attribute)를 선언합니다. 
지금은 위치 데이터 만 필요하기 대문에 하나의 정점 속성만 있으면 됩니다. GLSL에는 벡터 타입이 있는데 
이는 접미사의 숫자에 따라 1~4개의 float을 포함할 수 있습니다. 각 정점은 3D 좌표를 가지므로 `vec3` 타입의 
입력 변수를 aPos라는 이름으로 선언합니다. 또한 `layout(location =0)을 통해 입력 변수의 위치를 명시적으로
지정하는데, 이후에 이 위치가 왜 필요한지 알아보게 될 것입니다. 

<Info>

### Vector 벡터 

그래픽스 프로그래밍에서 우리는 벡터라는 수학적 개념을 자주 사용합니다. 벡터는 어떤 공간에든 위치나 방향을 
깔끔하게 표현할 수 있고 유용한 수학적 성질을 가지고 있기 때문입니다. 

GLSL에서 벡터는 최대 크기가 4이며 각각의 값은 `vecx,vec y , vec z, vec w`로 접근할 수 있습니다. 
이들은 각각 공간상의 좌표를 의미합니다. 다만 `vec.w` 성분은 실제 3D 공간의 좝표로 쓰이지는 않습니다. 
(우리가 다루는 것은 4차원이 아니라 3차원이기 때문) 대신 `vec.w`는 투영 나눗셈(perspective division)이라는 
과정에서 사용됩니다. 

벡터에 대해서는 이후 장에서 훨씬 더 깊이 다루게 될 것입니다. 
</Info>


정점 쉐이더의 출력을 설정하려면 위치 데이터를 미리 정의된 <Blue>gl_position</Blue> 변수에 대입해야 합니다. 
이 변수는 내부적으로 `vec4` 타입입니다. <Red>main</Red> 함수가 끝날 때 우리가 <Blue>gl_Position</Blue>에 대입한 값이 
정점 쉐이더의 출력으로 사용됩니다. 

우리의 입력은 크기가 3인 벡터이므로 , 이를 크기가 4인 벡터로 변환해야 합니다. 이때는 `vec3` 값을 `vec4`생성자에 넣고 
`w` 성분을 `1.0f`로 설정하면 됩니다.(이 이유에 대해서는 나중 장에서 설명할 것입니다.)

현재의 정점 쉐이더는 아마도 우리가 생각할 수 있는 가장 간단한 정점 쉐이더일 것입니다. 왜냐면 입력 데이터를 
전혀 처리하지 않고 단순히 쉐이더 출력으로 넘겨주기만 했기 때문입니다. 실제 애플리케이션에서는 입력 데이터가 이미 
정규화 장치 좌표(NDC)에 있지 않은 경우가 대부분이므로 , 먼저 입력 데이터를 OpenGL의 가시 영역안에 들어오도록 좌표 변환을 해주어야 합니다. 



## Compling a shader 쉐이더 컴파일 하기 
우리는 정점 쉐이더를 위한 소스코드를 const C string에 저장하여 파일 상단에 놓습니다.

```cpp
const char *vertexShaderSource = "#version 330 core\n"
    "layout (location = 0) in vec3 aPos;\n"
    "void main()\n"
    "{\n"
    "   gl_Position = vec4(aPos.x, aPos.y, aPos.z, 1.0);\n"
    "}\0";
```


OpenGL이 쉐이더를 사용하기 위해서는 런타입에 소스코드에서 그것을 동적으로 컴파일 해야합니다. 
우리가 첫번째로 해야할 일은 쉐이터 객체(오브젝트)를 생성하는 것입니다. 
그리고 또다시 ID로 참조하게 됩니다. 그래서 우리는 정점 쉐이더를 `unsigned int`로 선언하고 
쉐이더를 <Func 
  name="glCreateShader"
  params='[{"name":"shaderType","type":"GLenum","description":"생성할 쉐이더의 타입을 지정합니다. GL_VERTEX_SHADER, GL_FRAGMENT_SHADER, GL_GEOMETRY_SHADER, GL_TESS_CONTROL_SHADER, GL_TESS_EVALUATION_SHADER, GL_COMPUTE_SHADER 중 하나입니다."}]'
  description="빈 쉐이더 객체를 생성하고 해당 쉐이더 객체에 대한 고유한 참조 ID를 반환합니다. 쉐이더 객체는 쉐이더 소스 코드를 저장하고 컴파일하는 데 사용됩니다. 오류가 발생하면 0을 반환합니다."
  example="unsigned int vertexShader = glCreateShader(GL_VERTEX_SHADER);\nunsigned int fragmentShader = glCreateShader(GL_FRAGMENT_SHADER);\n\n// 쉐이더 생성 확인\nif (vertexShader == 0) {\n    // 오류 처리\n}"
  tags='["Shaders", "OpenGL Objects"]'
/>로 생성합니다. 

```cpp
unsigned int vertexShader;
vertexShader = glCreateShader(GL_VERTEX_SHADER);
```

우리는 생성하고자하는 타입의 쉐이더를 <Func 
  name="glCreateShader"
  params='[{"name":"shaderType","type":"GLenum","description":"생성할 쉐이더의 타입을 지정합니다. GL_VERTEX_SHADER, GL_FRAGMENT_SHADER, GL_GEOMETRY_SHADER, GL_TESS_CONTROL_SHADER, GL_TESS_EVALUATION_SHADER, GL_COMPUTE_SHADER 중 하나입니다."}]'
  description="빈 쉐이더 객체를 생성하고 해당 쉐이더 객체에 대한 고유한 참조 ID를 반환합니다. 쉐이더 객체는 쉐이더 소스 코드를 저장하고 컴파일하는 데 사용됩니다. 오류가 발생하면 0을 반환합니다."
  example="unsigned int vertexShader = glCreateShader(GL_VERTEX_SHADER);\nunsigned int fragmentShader = glCreateShader(GL_FRAGMENT_SHADER);\n\n// 쉐이더 생성 확인\nif (vertexShader == 0) {\n    // 오류 처리\n}"
  tags='["Shaders", "OpenGL Objects"]'
/> 함수의 인자로 전달합니다. 정점 쉐이더(vertex shader)를 만들 것이므로 우리는 <Blue>GL_VERTEX_SHADER</Blue>를 넘겨줍니다. 

다음으로는 쉐이더 객체에 앞에서 만들었던 쉐이더 소스 코드를 넘겨주어 쉐이더를 컴파일 합니다. 

```cpp
glShaderSource(vertexShader, 1, &vertexShaderSource, NULL);
glCompileShader(vertexShader);
```

<Func 
  name="glShaderSource"
  params='[{"name":"shader","type":"GLuint","description":"소스 코드를 교체할 쉐이더 객체를 지정합니다."},{"name":"count","type":"GLsizei","description":"string 배열의 요소 개수를 지정합니다."},{"name":"string","type":"const GLchar**","description":"소스 코드를 포함하는 문자열들의 포인터 배열입니다."},{"name":"length","type":"const GLint*","description":"각 문자열의 길이를 지정하는 배열입니다. NULL이면 문자열이 null-terminated라고 가정합니다."}]'
  description="주어진 쉐이더 객체의 소스 코드를 교체합니다. 쉐이더가 컴파일될 때마다 현재 소스 코드가 사용됩니다."
  example="glShaderSource(vertexShader, 1, &vertexShaderSource, NULL);"
  tags='["Shaders", "Source Code"]'/> 함수는 첫번째 인자로 컴파일할 쉐이더 객체를 받습니다. 두번째 인자는 몇개의 string을 소스코드로 넘겨줄 것인지를 지정합니다. 현재는 한개만 
넘겨주므로 1로 설정합니다. 세번째 인자는 정점 쉐이더의 실제 소스 코드를 넘겨줍니다. 그리고 네번째 인자는 `NULL`로 둡니다. 

이제 <Func 
  name="glCompileShader"
  params='[{"name":"shader","type":"GLuint","description":"컴파일할 쉐이더 객체를 지정합니다."}]'
  description="쉐이더 객체를 컴파일합니다. 컴파일은 쉐이더 객체에 연결된 소스 코드 문자열을 기반으로 수행됩니다. 컴파일 상태는 쉐이더 객체의 일부로 저장되며, glGetShaderiv 함수를 통해 확인할 수 있습니다."
  example="glCompileShader(vertexShader);\n\n// 컴파일 성공 여부 확인\nint success;\nglGetShaderiv(vertexShader, GL_COMPILE_STATUS, &success);\nif (!success) {\n    // 컴파일 오류 처리\n}"
  tags='["Shaders", "Compilation"]'/>를 호출하여 쉐이더를 컴파일합니다.

<Info>
아마도 당신은 이제 <Func 
  name="glCompileShader"
  params='[{"name":"shader","type":"GLuint","description":"컴파일할 쉐이더 객체를 지정합니다."}]'
  description="쉐이더 객체를 컴파일합니다. 컴파일은 쉐이더 객체에 연결된 소스 코드 문자열을 기반으로 수행됩니다. 컴파일 상태는 쉐이더 객체의 일부로 저장되며, glGetShaderiv 함수를 통해 확인할 수 있습니다."
  example="glCompileShader(vertexShader);\n\n// 컴파일 성공 여부 확인\nint success;\nglGetShaderiv(vertexShader, GL_COMPILE_STATUS, &success);\nif (!success) {\n    // 컴파일 오류 처리\n}"
  tags='["Shaders", "Compilation"]'/>를 호출 후에 컴파일이 성공했는지 아닌지 확인하고 싶을 것입니다. 
만약 실패했다면 어떤 오류가 발생했는지 확인해서 고쳐야합니다. 컴파일 오류를 확인하는 방법은 다음과 같습니다. 

```cpp
int  success;
char infoLog[512];
glGetShaderiv(vertexShader, GL_COMPILE_STATUS, &success);
``` 

우선 성공 여부를 저장할 정수 변수 하나와 오류 메세지를 담을 버퍼(문자 배열)을 정의합니다. 그런다음 
<Func 
  name="glGetShaderiv"
  params='[{"name":"shader","type":"GLuint","description":"쿼리할 쉐이더 객체를 지정합니다."},{"name":"pname","type":"GLenum","description":"객체 파라미터를 지정합니다. GL_SHADER_TYPE, GL_DELETE_STATUS, GL_COMPILE_STATUS, GL_INFO_LOG_LENGTH, GL_SHADER_SOURCE_LENGTH 등이 있습니다."},{"name":"params","type":"GLint*","description":"요청된 객체 파라미터를 반환할 GLint 배열의 포인터입니다."}]'
  description="쉐이더 객체에 대한 정보를 쿼리할 수 있게 해주는 함수입니다. 개발자가 쉐이더 객체의 다양한 속성과 상태를 확인할 수 있습니다."
  example="GLint success;\nglGetShaderiv(vertexShader, GL_COMPILE_STATUS, &success);\n\n// 다른 정보들도 확인 가능\nGLint logLength;\nglGetShaderiv(shader, GL_INFO_LOG_LENGTH, &logLength);"
  tags='["Shaders", "Query"]'/>를 사용하여 컴파일이 성공했는지 확인합니다. 만약 컴파일이 실패했다면, <Func 
  name="glGetShaderInfoLog"
  params='[{"name":"shader","type":"GLuint","description":"정보 로그를 쿼리할 쉐이더 객체를 지정합니다."},{"name":"maxLength","type":"GLsizei","description":"반환된 정보 로그를 저장할 문자 버퍼의 크기를 지정합니다."},{"name":"length","type":"GLsizei*","description":"infoLog에 반환된 문자열의 길이를 반환합니다 (null terminator 제외). NULL이면 길이를 반환하지 않습니다."},{"name":"infoLog","type":"GLchar*","description":"정보 로그를 반환하는 데 사용되는 문자 배열을 지정합니다."}]'
  description="쉐이더 객체의 정보 로그를 반환합니다. 정보 로그에는 쉐이더 컴파일과 관련된 정보가 포함됩니다. 쉐이더 컴파일이 실패하면 컴파일 타임 오류를 확인하기 위해 쉐이더의 정보 로그를 확인하는 것이 좋습니다."
  example="char infoLog[512]; glGetShaderInfoLog(vertexShader, 512, NULL, infoLog);"
  tags='["Shaders", "Error Handling"]'/>를 호출해 오류 메세지를 가져오고 출력해야 합니다. 



```cpp
if(!success)
{
    glGetShaderInfoLog(vertexShader, 512, NULL, infoLog);
    std::cout << "ERROR::SHADER::VERTEX::COMPILATION_FAILED\n" << infoLog << std::endl;
}
```
</Info>

만약 에러가 발견되지 않았다면 정점 쉐이더는 이제 컴파일 된 것입니다. 


## Fragment shader 프레그먼트 쉐이더 

프레그먼트 쉐이더는 우리가 삼각형을 그리기위해 필요한 두번째이자 마지막 쉐이더 입니다. 
프레그먼트 쉐이더는 픽셀의 색상 출력 값을 계산하는 쉐이더입니다. 간단하게 하기위해 우선 프레그먼트 쉐이더가 
항상 오렌지색 색상을 출력하도록 하겠습니다. 

<Info>
컴퓨터 그래픽스에서 색상은 보통 4개의 값 배열로 표현됩니다. 빨강, 초록, 파랑,알파(불투명도) 성분입니다. 
이는 흔히 **RGBA**라고 부릅니다. OpenGL이나 GLSL에서 색상을 정의할 때는 각 성분의 강도를 
0.0에서 1.0 사이의 값으로 설정합니다. 예를 들어, 빨강을 1.0, 초록을 1.0으로 설정하면 
두 색상이 섞여서 노란색이 됩니다. 이렇게 세가지 색상 성분을 조합하면 1,600만 가지 이상의 색상을 
만들어 낼 수 있습니다. 

</Info>

```cpp
#version 330 core
out vec4 FragColor;

void main()
{
    FragColor = vec4(1.0f, 0.5f, 0.2f, 1.0f);
} 

```

프래그먼트 쉐이더(Fragment Shader)는 단 하나의 출력 변수를 필요로 하는데, 이는 최종 색상 출력을 정의하는 
크기 4의 벡터입니다. 출력값은 `out` 키워드로 설정할 수 있으며 여기서는 <Blue>FragColor</Blue>라는 이름으로 지정하겠습니다. 
다음으로  vec4값을 색상 출력에 대입했는데 , 이는 알파 값이 1.0(완전 불투명)한 주황색 입니다. 

프레그먼트 쉐이더를 컴파일하는 과정은 정점 쉐이더와 유사하지만, 이때는 쉐이더 타입으로 <Blue>GL_FRAGMENT_SHADER</Blue> 
상수를 사용합니다. 

```cpp
unsigned int fragmentShader;
fragmentShader = glCreateShader(GL_FRAGMENT_SHADER);
glShaderSource(fragmentShader, 1, &fragmentShaderSource, NULL);
glCompileShader(fragmentShader);

``` 

두개의 쉐이더가 이제 컴파일 되었으니 남은 일은 두개의 쉐이더 객체를 <Green>쉐이더 프로그램(Shader Program)</Green>에 
연결하는 것입니다. 여기서도 컴파일 에러를 확인하는 것을 잊지마세요! 


## Shader Program 쉐이더 프로그램 

쉐이더 프로그램(Shader Program) 객체는 여러 쉐이더들을 합쳐서 마지막으로 연결하는 것입니다. 
우리가 방금 컴파일한 쉐이더를 사용하려면 그것들을 쉐이더 프로그램 객체에 링크한 뒤, 렌더링 시 이 쉐이더 프로그램을 활성화 해야합니다. 
활성화된 쉐이더 프로그램의 쉐이더들이 우리가 렌더 호출을 했을 때 사용됩니다. 

쉐이더를 하나의 프로그램으로 링크할 때, 각 쉐이더의 출력은 다음 쉐이더의 입력과 연결됩니다. 만약 출려과 입력이 일치하지 않으면
이 단계에서 링크 오류가 발생합니다. 

프로그램 객체를 만드는 것은 간단합니다. 

```cpp
unsigned int shaderProgram;
shaderProgram = glCreateProgram();
```

<Func 
  name="glCreateProgram"
  params='[]'
  description="프로그램 객체를 생성하고 해당 프로그램 객체에 대한 고유한 참조 ID를 반환합니다. 프로그램 객체는 쉐이더들을 연결하고 링크하는 데 사용됩니다. 오류가 발생하면 0을 반환합니다."
  example="unsigned int shaderProgram = glCreateProgram();"
  tags='["Shaders", "Program Objects"]'
/> 함수는 프로그램을 생성하여 최근에 생성된 프로그램 객체의 ID참조를 반환합니다. 우리는 이제 
이전에 컴파일된 쉐이더들을 프로그램 객체에 붙이고 <Func 
  name="glLinkProgram"
  params='[{"name":"program","type":"GLuint","description":"링크할 프로그램 객체를 지정합니다."}]'
  description="연결된 모든 쉐이더를 하나의 최종 쉐이더 프로그램 객체로 링크합니다. 링크 단계에서 각 출력이 각 쉐이더의 입력과 일치하는지 확인하고, 일치하지 않으면 링크가 실패합니다."
  example="glLinkProgram(shaderProgram);"
  tags='["Shaders", "Program Linking"]'
/>으로 이들을 연결합니다. 

```cpp
glAttachShader(shaderProgram, vertexShader);
glAttachShader(shaderProgram, fragmentShader);
glLinkProgram(shaderProgram);
``` 

코드는 매우 직관적입니다. 우리는 쉐이더들을 프로그램에 붙인 뒤에  <Func 
  name="glLinkProgram"
  params='[{"name":"program","type":"GLuint","description":"링크할 프로그램 객체를 지정합니다."}]'
  description="연결된 모든 쉐이더를 하나의 최종 쉐이더 프로그램 객체로 링크합니다. 링크 단계에서 각 출력이 각 쉐이더의 입력과 일치하는지 확인하고, 일치하지 않으면 링크가 실패합니다."
  example="glLinkProgram(shaderProgram);"
  tags='["Shaders", "Program Linking"]'
/> 을 통해 그것들을 연결합니다. 


<Info>
Shader 컴파일때처럼 우리는 쉐이더 프로그램의 링킹의 실패도 체크해야합니다. 그리고 에러 로그를 반환해야 합니다. 
<Func 
  name="glGetShaderiv"
  params='[{"name":"shader","type":"GLuint","description":"쿼리할 쉐이더 객체를 지정합니다."},{"name":"pname","type":"GLenum","description":"객체 파라미터를 지정합니다. GL_SHADER_TYPE, GL_DELETE_STATUS, GL_COMPILE_STATUS, GL_INFO_LOG_LENGTH, GL_SHADER_SOURCE_LENGTH 등이 있습니다."},{"name":"params","type":"GLint*","description":"요청된 객체 파라미터를 반환할 GLint 배열의 포인터입니다."}]'
  description="쉐이더 객체에 대한 정보를 쿼리할 수 있게 해주는 함수입니다. 개발자가 쉐이더 객체의 다양한 속성과 상태를 확인할 수 있습니다."
  example="GLint success;\nglGetShaderiv(vertexShader, GL_COMPILE_STATUS, &success);\n\n// 다른 정보들도 확인 가능\nGLint logLength;\nglGetShaderiv(shader, GL_INFO_LOG_LENGTH, &logLength);"
  tags='["Shaders", "Query"]'/> 와 <Func 
  name="glGetShaderInfoLog"
  params='[{"name":"shader","type":"GLuint","description":"정보 로그를 쿼리할 쉐이더 객체를 지정합니다."},{"name":"maxLength","type":"GLsizei","description":"반환된 정보 로그를 저장할 문자 버퍼의 크기를 지정합니다."},{"name":"length","type":"GLsizei*","description":"infoLog에 반환된 문자열의 길이를 반환합니다 (null terminator 제외). NULL이면 길이를 반환하지 않습니다."},{"name":"infoLog","type":"GLchar*","description":"정보 로그를 반환하는 데 사용되는 문자 배열을 지정합니다."}]'
  description="쉐이더 객체의 정보 로그를 반환합니다. 정보 로그에는 쉐이더 컴파일과 관련된 정보가 포함됩니다. 쉐이더 컴파일이 실패하면 컴파일 타임 오류를 확인하기 위해 쉐이더의 정보 로그를 확인하는 것이 좋습니다."
  example="char infoLog[512]; glGetShaderInfoLog(vertexShader, 512, NULL, infoLog);"
  tags='["Shaders", "Error Handling"]'/> 대신 이번에는 아래처럼 사용합니다. 

  ```cpp 
glGetProgramiv(shaderProgram, GL_LINK_STATUS, &success);
if(!success) {
    glGetProgramInfoLog(shaderProgram, 512, NULL, infoLog);
    ...
}
```
</Info> 


프로그램 객체의 결과는 <Func 
  name="glUseProgram"
  params='[{"name":"program","type":"GLuint","description":"사용할 쉐이더 프로그램 객체를 지정합니다. 이 프로그램 객체는 컴파일되고 링크되어야 합니다."}]'
  description="주어진 프로그램 객체를 현재 활성 쉐이더 프로그램으로 설정하여 후속 그리기 명령에 사용합니다. 0 값이 제공되면 OpenGL은 이전 그리기 패턴으로 되돌아갑니다."
  example="glUseProgram(shaderProgram); glBindVertexArray(VAO); glDrawElements(GL_TRIANGLES, 6, GL_UNSIGNED_INT, 0); glBindVertexArray(0);"
  tags='["Shaders", "Program Usage"]'
/>을 통해 활성화할 수 있습니다. 
이때 새로 생성된 프로그램 객체를 인자로 넘겨줍니다. 

```cpp 
glUseProgram(shaderProgram);
```
 <Func 
  name="glUseProgram"
  params='[{"name":"program","type":"GLuint","description":"사용할 쉐이더 프로그램 객체를 지정합니다. 이 프로그램 객체는 컴파일되고 링크되어야 합니다."}]'
  description="주어진 프로그램 객체를 현재 활성 쉐이더 프로그램으로 설정하여 후속 그리기 명령에 사용합니다. 0 값이 제공되면 OpenGL은 이전 그리기 패턴으로 되돌아갑니다."
  example="glUseProgram(shaderProgram); glBindVertexArray(VAO); glDrawElements(GL_TRIANGLES, 6, GL_UNSIGNED_INT, 0); glBindVertexArray(0);"
  tags='["Shaders", "Program Usage"]'
/>이후의 모든 쉐이더와 렌더링 콜은 이제 이 프로그램 객체를 사용할 것입니다. 

아 그리고 잊지말아야할게 있습니다. 바로 쉐이더 객체들을 프로그램 객체에 연결한 후에는 더이상 필요하지 않으니 삭제해야합니다. 

```cpp 

glDeleteShader(vertexShader);
glDeleteShader(fragmentShader);

``` 

지금까지 우리는 입력 정점 데이터를 GPU에 전송했고, GPU가 정점과 프래그먼트 쉐이더에서 정점 데이터를 어떻게 처리해야하는지 지시했습니다. 
거의 다 왔지만 아직 한가지가 남아있습니다. OpenGL은 현재 메모리에 있는 정점 데이터를 어떻게 해석해야 하는지, 그리고 
이 데이터를 정점 쉐이더의 어떤 속성(attribute)에 연결해야하는지 알지 못합니다. 이제 우리가 OpenGL에게 그것을 알려줘야합니다. 

## Linking Vertex Attributes 정점 속성 연결 

정점 쉐이더는 정점 속성(vertex Attribute) 형태로 원하는 입력을 자유롭게 지정할 수 있습니다. 이는 큰 유연성을 제공하지만,
동시에 우리가 입력 데이터의 어떤 부분이 정점 쉐이더의 어떤 속성에 대응되는지를 직접 지정해야한다는 뜻이기도 합니다. 
즉 렌더링 하기 전에 OpenGL이 정점 데이터를 어떻게 해석해야 하는지 우리가 명시해야합니다. 

우리의 정점 버퍼 데이터는 다음과 같은 형식으로 되어 있습니다. 

![vertex_attribute_pointer](./images/getting-started/vertex_attribute_pointer.png)


- 위치 데이터는 32-bit(4 byte) float 점 형태로 저장됩니다. 
- 각 위치(Position)은 이러한 값 3개로 이루어져 있습니다. 
- 각 3개 값의 집합 사이에는 다른 값이나 빈 공간이 없습니다. 배열 안에서 값들이 연속적으로 저장되어 있습니다. 
- 데이터의 첫번째 값은 버퍼의 맨앞에서 시작합니다. 

이 정보를 바탕으로, 우리는 <Func 
  name="glVertexAttribPointer"
  params='[{"name":"index","type":"GLuint","description":"정점 속성의 인덱스를 지정합니다."},{"name":"size","type":"GLint","description":"정점 속성당 구성 요소의 수를 지정합니다. 1, 2, 3, 4 중 하나여야 합니다."},{"name":"type","type":"GLenum","description":"배열의 각 구성 요소의 데이터 타입을 지정합니다. GL_BYTE, GL_UNSIGNED_BYTE, GL_SHORT, GL_UNSIGNED_SHORT, GL_INT, GL_UNSIGNED_INT, GL_FLOAT, GL_DOUBLE 등이 있습니다."},{"name":"normalized","type":"GLboolean","description":"데이터가 정규화되어야 하는지 지정합니다. 정수 값의 경우 0에서 1 범위(부호 없는 값) 또는 -1에서 1 범위(부호 있는 값)로 매핑됩니다."},{"name":"stride","type":"GLsizei","description":"연속된 정점 속성 사이의 바이트 오프셋을 지정합니다. 정점 속성이 밀접하게 패킹되어 있으면 0을 사용할 수 있습니다."},{"name":"pointer","type":"const GLvoid*","description":"배열의 첫 번째 구성 요소의 첫 번째 정점 속성에 대한 오프셋을 지정합니다."}]'
  description="그리기 호출이 이루어질 때마다 정점 버퍼 데이터를 어떻게 해석해야 하는지 지정합니다. 해석 지정은 현재 바인딩된 정점 배열 객체에 저장되며 일부 상태 변경 시까지 유효합니다."
  example="glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(float), (void*)0);"
  tags='["Vertex Attributes", "Buffer Management"]'
/>를 사용하여 OpenGL에게 정점 데이터를 정점 속성 단위로 어떻게 해석해야 하는지 알려줄 수 있습니다. 

```cpp 
glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(float), (void*)0);
glEnableVertexAttribArray(0);  

```
<Func 
  name="glVertexAttribPointer"
  params='[{"name":"index","type":"GLuint","description":"정점 속성의 인덱스를 지정합니다."},{"name":"size","type":"GLint","description":"정점 속성당 구성 요소의 수를 지정합니다. 1, 2, 3, 4 중 하나여야 합니다."},{"name":"type","type":"GLenum","description":"배열의 각 구성 요소의 데이터 타입을 지정합니다. GL_BYTE, GL_UNSIGNED_BYTE, GL_SHORT, GL_UNSIGNED_SHORT, GL_INT, GL_UNSIGNED_INT, GL_FLOAT, GL_DOUBLE 등이 있습니다."},{"name":"normalized","type":"GLboolean","description":"데이터가 정규화되어야 하는지 지정합니다. 정수 값의 경우 0에서 1 범위(부호 없는 값) 또는 -1에서 1 범위(부호 있는 값)로 매핑됩니다."},{"name":"stride","type":"GLsizei","description":"연속된 정점 속성 사이의 바이트 오프셋을 지정합니다. 정점 속성이 밀접하게 패킹되어 있으면 0을 사용할 수 있습니다."},{"name":"pointer","type":"const GLvoid*","description":"배열의 첫 번째 구성 요소의 첫 번째 정점 속성에 대한 오프셋을 지정합니다."}]'
  description="그리기 호출이 이루어질 때마다 정점 버퍼 데이터를 어떻게 해석해야 하는지 지정합니다. 해석 지정은 현재 바인딩된 정점 배열 객체에 저장되며 일부 상태 변경 시까지 유효합니다."
  example="glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(float), (void*)0);"
  tags='["Vertex Attributes", "Buffer Management"]'
/> 함수는 꽤 몇가지의 매개변수들을 가지고 있습니다. 그러니 천천히 그것들을 살펴 봅시다. 

<NumberedList>
<NumberedItem>**첫번째 매개변수** 는 어떤 정점 속성(vertex attribvute)을 설정할지 지정합니다. 정점 쉐이더에서 `layout(location = 0)`으로 위치 속성의 로케이션을 0으로 지정했으므로, 여기에 0을 넣어 그 속성에 데이터를 전달합니다.</NumberedItem>
<NumberedItem>**두번째 인자** 는 정점 속성의 크기입니다. 위치 속성은 `vec3`이므로 값 3개로 이뤄져 3을 넣습니다.</NumberedItem>
<NumberedItem>**세번째 인자** 는 데이터의 타입입니다. 우리는 부동소수점이므로 `GL_FLOAT`을 씁니다. (GLSL의 `vec*`는 float들로 구성)</NumberedItem>
<NumberedItem>**네번째 인자** 는 정규화 여부입니다. 만약 정수형(int, byte 등) 데이터를 넣고 이 값을 `GL_TRUE`로 하면, float로 변환될 때 0(부호가 있으면 -1)~1 범위로 정규화됩니다. 지금은 해당 없음 → `GL_FALSE`.</NumberedItem>
<NumberedItem>**다섯번째 인자(stride)** 는 연속한 정점 속성 사이의 바이트 간격입니다. 다음 위치 데이터까지의 거리가 float 3개의 크기이므로 그 값을 넣습니다. 배열이 타이트하게(packed) 붙어 있음을 알고 있다면, 0을 줘서 OpenGL이 자동으로 계산하게 할 수도 있습니다(값들이 촘촘히 붙어 있을 때만).</NumberedItem>
<NumberedItem>**마지막 인자** 는 `void*` 타입의 오프셋(바이트 단위)으로, 버퍼 안에서 해당 속성 데이터가 시작되는 위치입니다. 위치 데이터가 배열의 맨 앞에서 시작하므로 0입니다. 이 파라미터는 나중에 더 자세히 다룹니다.</NumberedItem>
</NumberedList>


<Info>
각 정점 속성(Vertex Attribute)는 VBO가 관리하는 메모리에서 데이터를 가져오며 어떤 VBO에서 데이터를 가져올지는 (여러개의 VBO를 가지고 있을 수 있으므로로) <Func 
  name="glVertexAttribPointer"
  params='[{"name":"index","type":"GLuint","description":"정점 속성의 인덱스를 지정합니다."},{"name":"size","type":"GLint","description":"정점 속성당 구성 요소의 수를 지정합니다. 1, 2, 3, 4 중 하나여야 합니다."},{"name":"type","type":"GLenum","description":"배열의 각 구성 요소의 데이터 타입을 지정합니다. GL_BYTE, GL_UNSIGNED_BYTE, GL_SHORT, GL_UNSIGNED_SHORT, GL_INT, GL_UNSIGNED_INT, GL_FLOAT, GL_DOUBLE 등이 있습니다."},{"name":"normalized","type":"GLboolean","description":"데이터가 정규화되어야 하는지 지정합니다. 정수 값의 경우 0에서 1 범위(부호 없는 값) 또는 -1에서 1 범위(부호 있는 값)로 매핑됩니다."},{"name":"stride","type":"GLsizei","description":"연속된 정점 속성 사이의 바이트 오프셋을 지정합니다. 정점 속성이 밀접하게 패킹되어 있으면 0을 사용할 수 있습니다."},{"name":"pointer","type":"const GLvoid*","description":"배열의 첫 번째 구성 요소의 첫 번째 정점 속성에 대한 오프셋을 지정합니다."}]'
  description="그리기 호출이 이루어질 때마다 정점 버퍼 데이터를 어떻게 해석해야 하는지 지정합니다. 해석 지정은 현재 바인딩된 정점 배열 객체에 저장되며 일부 상태 변경 시까지 유효합니다."
  example="glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(float), (void*)0);"
  tags='["Vertex Attributes", "Buffer Management"]'
/>를 호출할때 <Blue>GL_ARRAY_BUFFER</Blue>에 현재 바인딩된 VBO에 의해 결정됩니다. 즉 우리가 <Red>glVertexArrayPointer</Red>를 
호출하기 전에 이미 정의해둔 VBO가 여전히 바인딩 되어 있으므로, 정점 속성 location = 0 은 이제 그 VBO의 정점 데이터와 연결됩니다. 

</Info> 


<TranslatorNote type="clarification" author="이도경" collapsible={true} defaultOpen={false}>

#### 슬롯(location) 이란? 
역할: 정점 데이터(VBO)의 특정 부분을 -> 쉐이더의 입력 변수에 연결하는 번호표 

예시 
```cpp
layout (location = 0) in vec3 aPos;    // 위치 → 슬롯 0
layout (location = 1) in vec3 aColor;  // 색상 → 슬롯 1
```

즉 슬롯(location)  = "VBO 데이터와 쉐이더 변수를 연결하는 번호" 

</TranslatorNote> 

이제 OpenGL이 정점 데이터를 어떻게 해석해야하는지 지정했으니, <Func 
  name="glEnableVertexAttribArray"
  params='[{"name":"index","type":"GLuint","description":"활성화할 정점 속성의 인덱스를 지정합니다."}]'
  description="일반 정점 속성을 활성화합니다. 정점 속성은 glDisableVertexAttribArray를 호출하여 비활성화할 수 있습니다."
  example="glEnableVertexAttribArray(0);"
  tags='["Vertex Attributes"]'
/>를 사용해 정점 속성을 활성화 해야합니다. 이 함수에는 정점 속성의 location(슬롯) 값을 인자로 전달합니다. (정점 속성은 기본적으로 비활성화 상태입니다.)
그 시점부터 우리는 모든 설정을 완료한 것입니다.

- 정점 버퍼 객체(VBO)를 이용해 버퍼에 정점 데이터를 초기화 했고 
- 정점 쉐이더와 프래그먼트 쉐이더를 설정했으며 
- OpenGL에게 정점 데이터를 정점 쉐이더의 정점 속성과 어떻게 연결해야하는지 알려주었습니다. 

이제 OpenGL에서 객체를 그리는 코드는 다음과 같이 보이게 됩니다. 

```cpp 

// 0. OpenGL이 사용할 수 있도록 정점 배열을 버퍼에 복사
glBindBuffer(GL_ARRAY_BUFFER, VBO);
glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW);
// 1. 정점 속성 포인터 설정
glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(float), (void*)0);
glEnableVertexAttribArray(0);  
// 2. 객체를 렌더링할 때 쉐이더 프로그램 사용
glUseProgram(shaderProgram);
// 3. 이제 객체 그리기
someOpenGLFunctionThatDrawsOurTriangle();   
```

우리는 어떤 객체를 그릴 때마다 이 과정을 반복해야 합니다. 지금은 별로 많아 보이지 않을 수 있지만, 정점 속성이 5개 이상이고 
객체가 수백 개나 된다면(이는 흔한 일입니다.) 각 객체마다 적절한 버퍼 객체를 바인딩하고 모든 정점 속성을 설정하는 일은 
금방 번거로운 작업이 됩니다. 

만약 이 모든 상태 설정을 하나의 객체에 저장해 두고 , 그 객체를 단순히 바인딩 하는 것만으로 해당 상태를 가져올 수 있다면 어떨까요? 

## Vertex Array Object 정점 배열 객체 

<Green> 정점 배열 객체 (vertex array object) VAO </Green>는 정점 버퍼 객체(VBO) 처럼 바인딩 할 수 있으며, 그 ㅈ시점
이후의 모든 정점 속성 호출들은 VAO안에 저장됩니다. 이렇게 하면 정점 속성 포인터를 설정할 때 단 한번ㅁ나 호출하면 되고, 객체를 그릴때는 
해당 VAO만 바인딩 하면 됩니다. 즉 서로 다른 정점 데이터와 속성 구성을 전환하는 일이 단순히 다른 
VAO를 바인딩하는 것 만큼 쉬워집니다. 지금까지 설정 했던 모든 상태가 VAO에 저장되기 때문입니다. 

<Warning>
코어 OpenGL은 VAO를 사용하는 것을 필요로 합니다. 우리가 정점 입력값으로 어떤 일을 할지 알게하기 위해서입니다. 
만약에 VAO를 바인딩하는 것에 실패한다면  OpenGL은 무언가를 그리는 것을 거부할 수 있습니다. 
</Warning> 

정점 배열 객체(VAO)는 다음들을 저장합니다. 

- <Func 
    name="glEnableVertexAttribArray"
    params='[{"name":"index","type":"GLuint","description":"활성화할 정점 속성의 인덱스를 지정합니다."}]'
    description="일반 정점 속성을 활성화합니다. 정점 속성은 glDisableVertexAttribArray를 호출하여 비활성화할 수 있습니다."
    example="glEnableVertexAttribArray(0);"
    tags='["Vertex Attributes"]'
  /> 또는 <Red>glDisableVertexAttribArray</Red> 호출
- <Func 
  name="glVertexAttribPointer"
  params='[{"name":"index","type":"GLuint","description":"정점 속성의 인덱스를 지정합니다."},{"name":"size","type":"GLint","description":"정점 속성당 구성 요소의 수를 지정합니다. 1, 2, 3, 4 중 하나여야 합니다."},{"name":"type","type":"GLenum","description":"배열의 각 구성 요소의 데이터 타입을 지정합니다. GL_BYTE, GL_UNSIGNED_BYTE, GL_SHORT, GL_UNSIGNED_SHORT, GL_INT, GL_UNSIGNED_INT, GL_FLOAT, GL_DOUBLE 등이 있습니다."},{"name":"normalized","type":"GLboolean","description":"데이터가 정규화되어야 하는지 지정합니다. 정수 값의 경우 0에서 1 범위(부호 없는 값) 또는 -1에서 1 범위(부호 있는 값)로 매핑됩니다."},{"name":"stride","type":"GLsizei","description":"연속된 정점 속성 사이의 바이트 오프셋을 지정합니다. 정점 속성이 밀접하게 패킹되어 있으면 0을 사용할 수 있습니다."},{"name":"pointer","type":"const GLvoid*","description":"배열의 첫 번째 구성 요소의 첫 번째 정점 속성에 대한 오프셋을 지정합니다."}]'
  description="그리기 호출이 이루어질 때마다 정점 버퍼 데이터를 어떻게 해석해야 하는지 지정합니다. 해석 지정은 현재 바인딩된 정점 배열 객체에 저장되며 일부 상태 변경 시까지 유효합니다."
  example="glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(float), (void*)0);"
  tags='["Vertex Attributes", "Buffer Management"]'
  />를 통한 정점 속성 설정
- glVertexAttribPointer 호출에 의해 정점 속성과 연결된 정점 버퍼 객체

![vertex_array_objects](./images/getting-started/vertex_array_objects.png)

VAO를 생성하는 절차는 VBO 생성 절차와 유사합니다. 

```cpp
unsigned int VAO;
glGenVertexArrays(1, &VAO);  
```
VAO를 사용하기 위해서는 VAO를 <Func 
  name="glBindVertexArray"
  params='[{"name":"array","type":"GLuint","description":"바인딩할 VAO를 지정합니다."}]'
  description="정점 배열 객체를 바인딩합니다. 이후의 모든 VBO, EBO, glVertexAttribPointer 및 glEnableVertexAttribArray 호출이 현재 바인딩된 VAO 내부에 저장됩니다."
  example="glBindVertexArray(VAO);"
  tags='["Vertex Arrays", "OpenGL State"]'
/>를 이용해 바인딩해야합니다. 
그 시점에서 우리는 해당 VBO와 정점 속성 포인터를 바인딩/설정 한뒤, 나중을 위해 VAO를 언바인딩 하면 됩니다. 
어떤 객체를 그리려고 할 때는 단순히 원하는 설정이 저장된 VBO를 바인딩하고 나서 그리기(draw) 호출을 하면 끝입니다. 
코드로 표현하면 대략 다음과 같습니다. 

```cpp
// ..:: Initialization code (done once (unless your object frequently changes)) :: ..
// 1. bind Vertex Array Object
glBindVertexArray(VAO);
// 2. copy our vertices array in a buffer for OpenGL to use
glBindBuffer(GL_ARRAY_BUFFER, VBO);
glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW);
// 3. then set our vertex attributes pointers
glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(float), (void*)0);
glEnableVertexAttribArray(0);  

  
[...]

// ..:: Drawing code (in render loop) :: ..
// 4. draw the object
glUseProgram(shaderProgram);
glBindVertexArray(VAO);
someOpenGLFunctionThatDrawsOurTriangle();   
```

이제 끝입니다! 우리가 한 모든 일들이 이순간을 위해 이루어진 것입니다/ VAO는 우리의 정점 속성 구성과 
사용할 VBO를 저장합니다. 보통 여러 객체를 그려야 할 때는, 먼저 VAO(그리고 필요한 VBO 정점 속성 포인터)를 생성/설정해
두고 나중을 위해 저장해 둡니다. 그리고 특정 객체를 그리려는 순간, 해당 VAO를 가져와서 바인딩 하고, 객체를 그린뒤 
다시 VAO를 언 바인딩 하면 됩니다. 


## 드디어 기다렸던 삼각형!

우리가 원하는 객체를 그리기 위해 OpenGL은 <Func 
  name="glDrawArrays"
  params='[{"name":"mode","type":"GLenum","description":"그릴 프리미티브의 종류를 지정합니다. GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES 등이 가능합니다."},{"name":"first","type":"GLint","description":"활성화된 배열에서 시작할 인덱스를 지정합니다."},{"name":"count","type":"GLsizei","description":"렌더링할 정점의 개수를 지정합니다."}]'
  description="현재 바인딩된 정점 배열 객체(또는 정점 배열 객체 없이 직접 바인딩된 정점 버퍼)로부터 정점을 그립니다. 이 함수는 현재 활성화된 쉐이더 프로그램, 정점 속성 구성, VBO의 정점 데이터를 사용하여 프리미티브를 렌더링합니다."
  example="glDrawArrays(GL_TRIANGLES, 0, 3);"
  tags='["Drawing", "Rendering"]'
/> 함수를 제공합니다. 이 함수는 현재 활성화된 쉐이더, 
이전에 설정해 둔 정점 속성 구성, 그리고 VBO의 정점 데이터(VAO를 통해 간접적으로 연결된)를 사용해 
프리미티브를 그립니다. 

**glDrawArrays 함수의 매개변수:**

- **mode**: 그릴 프리미티브의 종류를 지정합니다. GL_POINTS, GL_LINES, GL_TRIANGLES 등이 가능합니다.
- **first**: 활성화된 배열에서 시작할 인덱스를 지정합니다.
- **count**: 렌더링할 정점의 개수를 지정합니다.

glDrawArrays함수의 첫번째 인자는 우리가 그리고자 하는 OpenGL 프리미티브 종류입니다. 처음에 삼각형을 
그리겠다고 했고 저는 거짓말하는 것을 싫어하니 , <Blue>GL_TRIANGLES</Blue>를 넘겨주겟습니다. 
두번째 인자는 그릴 정점 배열의 시작 인덱스를 지정하며 여기서는 `0`으로 둡니다. 마지막 인자는그릴 정점의 개수를 의미하며 여기서는 3입니다. 
(데이터에서 삼각형 1개만 렌더링 하므로 정확히 정점 3개) 

이제 코드를 컴파일 해보고 에러가 생기면 거꾸로 올라가며 문제를 확인해 보세요, 애플리케이션이 컴파일 되면 
다음과 같은 결과가 보여야 합니다. 


![hellotriangle](./images/getting-started/hellotriangle.png)

완성된 프로그램의 소스코드는 여기서 확인할 수 있습니다. <LinkBlock url="https://learnopengl.com/code_viewer_gh.php?code=src/1.getting_started/2.1.hello_triangle/hello_triangle.cpp" text="전체코드"/> 


만약 결과가 다음과 같지 않다면 과정에서 잘못 수행한 것이 있을테니 전체 코드를 확인하고 놓친 것이 없는지 보세요 

## Element Buffer Objects EBO 

정점을 렌더링 할때 마지막으로 확인하고 싶은 한가지가 있습니다. 바로 <Green> element buffer objects (EBO)</Green>
입니다. EBO의 동작 방식을 설명하려면 예시를 드는 것이 가장 좋습니다. 

예를 들어, 우리가 삼각형 대신 사각형을 그리고 싶다고 해봅시다. OpenGL은 기본적으로 삼각형을 사용하기 때문에 
사각형을 그리려면 두개의 삼각형으로 나누어야 합니다. 이렇게 하려면 다음과 같은 정점 집합이 만들어 집니다. 

```cpp 
float vertices[] = {
    // first triangle
     0.5f,  0.5f, 0.0f,  // top right
     0.5f, -0.5f, 0.0f,  // bottom right
    -0.5f,  0.5f, 0.0f,  // top left 
    // second triangle
     0.5f, -0.5f, 0.0f,  // bottom right
    -0.5f, -0.5f, 0.0f,  // bottom left
    -0.5f,  0.5f, 0.0f   // top left
}; 
```

보시다시피 지정된 정점들 사이에 중복이 있습니다. 오른쪽 아래 정점과 위쪽 위 정점을 두번씩 지정하고 있습니다. 
이는 사각형을 표현하는데 정점 4개만으로도 충분하기 때문에 6개를 쓰게된다면 50%의 오버헤드가 생긴 것입니다. 
이런 비효율은 수천 개의 삼각형으로 이루어진 복잡한 모델로 갈수록 심각해지며, 겹치는 정점들이 대량으로 발생하게 됩니다. 

더 좋은 해결책은 고유한 정점들만 저장하고 우리가 이 정점들을 어떤 순서로 그릴지를 따로 지정하는 것입니다. 
이렇게 하면 사각형을 표현할때 정점은 4개만 저장하고, 그 정점들을 어떤 순서로 그릴지만 지정하면 됩니다. 
OpenGL이 이런 기능을 제공한다면 정말 좋지 않을까요?

다행히도, EBO가 바로 그렇게 동작합니다. EBO는 정점 버퍼 객체(VBO)와 비슷한 버퍼인데 OpenGL이 어떤 정점을 그릴지 
결정할 때 사용할 인덱스를 저장합니다. 이렇게 인덱스를 사용하는 방식을 Indexed drawing 이라고 부르며 이 방법이 바로 
우리의 문제에 대한 해결책 입니다. 

이를 시작하려면, 먼저 고유한 정점들과 이를 사각형으로 그리기 위한 인덱스 배열을 지정해야 합니다. 

```cpp 
float vertices[] = {
     0.5f,  0.5f, 0.0f,  // top right
     0.5f, -0.5f, 0.0f,  // bottom right
    -0.5f, -0.5f, 0.0f,  // bottom left
    -0.5f,  0.5f, 0.0f   // top left 
};
unsigned int indices[] = {  // note that we start from 0!
    0, 1, 3,   // first triangle
    1, 2, 3    // second triangle
};  
``` 
보시다시피 인덱스들을 사용하면 4개의 정점만 필요한 것을 볼 수 있습니다. 다음으로 우리는 EBO를 생성합니다. 

```cpp

unsigned int EBO;
glGenBuffers(1, &EBO);
``` 

VBO와 유사하게 EBO는 인덱스들을 버퍼에 <Func 
  name="glBindBuffer"
  params='[{"name":"target","type":"GLenum","description":"바인딩할 버퍼의 타입을 지정합니다. 가장 일반적인 것은 GL_ARRAY_BUFFER와 GL_ELEMENT_ARRAY_BUFFER입니다."},{"name":"buffer","type":"GLuint","description":"바인딩할 버퍼 객체의 ID입니다. 0을 전달하면 현재 바인딩된 버퍼를 해제합니다."}]'
  description="버퍼 객체를 현재 버퍼 타입 타겟에 바인딩합니다. 한 번에 각 버퍼 타입당 하나의 버퍼만 바인딩될 수 있습니다. 버퍼를 바인딩하면 해당 타입에 대한 모든 후속 버퍼 작업이 현재 바인딩된 버퍼에 적용됩니다."
  example="glBindBuffer(GL_ARRAY_BUFFER, VBO);\n// 이제 GL_ARRAY_BUFFER 타겟에 대한 모든 작업이 VBO에 적용됩니다\n\n// 바인딩 해제\nglBindBuffer(GL_ARRAY_BUFFER, 0);"
  tags='["Buffer Management", "OpenGL State"]'
/> 를 사용하여 복사할 수 있습니다. 또한 VBO와 유사하게 우리는 바인딩하는 사이에 이 콜을 넣고 ,혹은 언바인딩 할수도 있습니다. 
대신에 이번에는 <Blue>GL_ELEMENT_ARRAY_BUFFER</Blue>를 사용해야 합니다. 

```cpp 

glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, EBO);
glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(indices), indices, GL_STATIC_DRAW); 
```

이제 우리는 버퍼 타겟으로 <Blue>GL_ELEMENT_ARRAY_BUFFER</Blue>를 사용하고 있다는 점에 주목하세요. 
마지막으로 해야 할 일은  <Func 
  name="glDrawArrays"
  params='[{"name":"mode","type":"GLenum","description":"그릴 프리미티브의 종류를 지정합니다. GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES 등이 가능합니다."},{"name":"first","type":"GLint","description":"활성화된 배열에서 시작할 인덱스를 지정합니다."},{"name":"count","type":"GLsizei","description":"렌더링할 정점의 개수를 지정합니다."}]'
  description="현재 바인딩된 정점 배열 객체(또는 정점 배열 객체 없이 직접 바인딩된 정점 버퍼)로부터 정점을 그립니다. 이 함수는 현재 활성화된 쉐이더 프로그램, 정점 속성 구성, VBO의 정점 데이터를 사용하여 프리미티브를 렌더링합니다."
  example="glDrawArrays(GL_TRIANGLES, 0, 3);"
  tags='["Drawing", "Rendering"]'
/> 호출을 <Func 
  name="glDrawElements"
  params='[{"name":"mode","type":"GLenum","description":"그릴 프리미티브의 종류를 지정합니다. GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES 등이 가능합니다."},{"name":"count","type":"GLsizei","description":"그릴 정점/요소의 개수를 지정합니다 (인덱스 사용)."},{"name":"type","type":"GLenum","description":"인덱스 값들의 타입을 지정합니다. GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT, GL_UNSIGNED_INT 중 하나입니다."},{"name":"indices","type":"const GLvoid*","description":"인덱스가 저장된 버퍼의 오프셋을 지정하거나 인덱스 배열에 대한 포인터입니다 (EBO가 바인딩되지 않은 경우)."}]'
  description="현재 바인딩된 VBO와 EBO를 사용하여 인덱스 기반 렌더링을 수행합니다. 이 함수는 indexed drawing을 가능하게 하여 중복된 정점을 제거하고 glDrawArrays보다 효율적인 렌더링을 제공합니다. EBO에 저장된 인덱스 순서에 따라 VBO의 정점들을 그립니다."
  example="glDrawElements(GL_TRIANGLES, 6, GL_UNSIGNED_INT, 0);"
  tags='["Drawing", "Rendering", "Indexed Drawing"]'
/>로 바꾸는 것입니다. 
이는 인덱스 버퍼에서 삼각형을 렌더링하고 싶다는 것을 나타냅니다. <Func 
  name="glDrawElements"
  params='[{"name":"mode","type":"GLenum","description":"그릴 프리미티브의 종류를 지정합니다. GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES 등이 가능합니다."},{"name":"count","type":"GLsizei","description":"그릴 정점/요소의 개수를 지정합니다 (인덱스 사용)."},{"name":"type","type":"GLenum","description":"인덱스 값들의 타입을 지정합니다. GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT, GL_UNSIGNED_INT 중 하나입니다."},{"name":"indices","type":"const GLvoid*","description":"인덱스가 저장된 버퍼의 오프셋을 지정하거나 인덱스 배열에 대한 포인터입니다 (EBO가 바인딩되지 않은 경우)."}]'
  description="현재 바인딩된 VBO와 EBO를 사용하여 인덱스 기반 렌더링을 수행합니다. 이 함수는 indexed drawing을 가능하게 하여 중복된 정점을 제거하고 glDrawArrays보다 효율적인 렌더링을 제공합니다. EBO에 저장된 인덱스 순서에 따라 VBO의 정점들을 그립니다."
  example="glDrawElements(GL_TRIANGLES, 6, GL_UNSIGNED_INT, 0);"
  tags='["Drawing", "Rendering", "Indexed Drawing"]'
/>를 사용할 때는 
현재 바인딩된 element buffer object (EBO)에서 제공되는 인덱스를 사용하여 그리게 됩니다


```cpp 
glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, EBO);
glDrawElements(GL_TRIANGLES, 6, GL_UNSIGNED_INT, 0);
```

첫번째 인자는 <Func 
  name="glDrawArrays"
  params='[{"name":"mode","type":"GLenum","description":"그릴 프리미티브의 종류를 지정합니다. GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES 등이 가능합니다."},{"name":"first","type":"GLint","description":"활성화된 배열에서 시작할 인덱스를 지정합니다."},{"name":"count","type":"GLsizei","description":"렌더링할 정점의 개수를 지정합니다."}]'
  description="현재 바인딩된 정점 배열 객체(또는 정점 배열 객체 없이 직접 바인딩된 정점 버퍼)로부터 정점을 그립니다. 이 함수는 현재 활성화된 쉐이더 프로그램, 정점 속성 구성, VBO의 정점 데이터를 사용하여 프리미티브를 렌더링합니다."
  example="glDrawArrays(GL_TRIANGLES, 0, 3);"
  tags='["Drawing", "Rendering"]'
/> 와 마찬가지로, 우리가 어떤 모드로 그릴지를 지정합니다. 두 번째 인자는 그릴 요소(element)의 개수로
우리는 인덱스를 6개 지정했으므로 총 6개의 정점을 그리게 됩니다. 
세번째 인자는 인덱스의 자료형으로, 여기서는 <Blue>GL_UNSIGNED_INT</Blue>입니다. 
마지막 인자는 EBO안에서의 오프셋을 지정할 수 있는 값입니다.(또는 인덱스 배열을 직접 전달 수도 있지만, 이는
EBO를 사용하지 않을 때 해당합니다. ) 여기서는 단순히 0으로 두겠습니다. 
 <Func 
  name="glDrawElements"
  params='[{"name":"mode","type":"GLenum","description":"그릴 프리미티브의 종류를 지정합니다. GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES 등이 가능합니다."},{"name":"count","type":"GLsizei","description":"그릴 정점/요소의 개수를 지정합니다 (인덱스 사용)."},{"name":"type","type":"GLenum","description":"인덱스 값들의 타입을 지정합니다. GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT, GL_UNSIGNED_INT 중 하나입니다."},{"name":"indices","type":"const GLvoid*","description":"인덱스가 저장된 버퍼의 오프셋을 지정하거나 인덱스 배열에 대한 포인터입니다 (EBO가 바인딩되지 않은 경우)."}]'
  description="현재 바인딩된 VBO와 EBO를 사용하여 인덱스 기반 렌더링을 수행합니다. 이 함수는 indexed drawing을 가능하게 하여 중복된 정점을 제거하고 glDrawArrays보다 효율적인 렌더링을 제공합니다. EBO에 저장된 인덱스 순서에 따라 VBO의 정점들을 그립니다."
  example="glDrawElements(GL_TRIANGLES, 6, GL_UNSIGNED_INT, 0);"
  tags='["Drawing", "Rendering", "Indexed Drawing"]'
/> 함수는 <Blue>GL_ELEMENT_ARRAY_BUFFER</Blue> 타깃에 바인딩된 EBO(Element Buffer Object)로 부터 인덱스를 
가져옵니다. 따라서 인덱스를 사용해 객체를 렌더링 할때마다 해당하는 EBO를 바인딩해야하는데 이는 조금 번거롭습니다.
그런데 마침, VAO(Vertex Array Object)가 EBO의 바인딩 상태도 함께 기억해 둡니다. 
즉 어떤 VAO가 바인딩 되어있을 때 마지막으로 바인딩된 EBO는 해당 VAO의 EBO로 저장됩니다. 
따라서 나중에 그 VAO를 바인딩하면 연결된 EBO도 자동으로 바인딩 됩니다. 

![vertex_array_objects_ebo](./images/getting-started/vertex_array_objects_ebo.png)

<Warning>

VAO는 타겟이 <Blue>GL_ELEMENT_ARRAY_BUFFER</Blue> 일때 <Func 
  name="glBindBuffer"
  params='[{"name":"target","type":"GLenum","description":"바인딩할 버퍼의 타입을 지정합니다. 가장 일반적인 것은 GL_ARRAY_BUFFER와 GL_ELEMENT_ARRAY_BUFFER입니다."},{"name":"buffer","type":"GLuint","description":"바인딩할 버퍼 객체의 ID입니다. 0을 전달하면 현재 바인딩된 버퍼를 해제합니다."}]'
  description="버퍼 객체를 현재 버퍼 타입 타겟에 바인딩합니다. 한 번에 각 버퍼 타입당 하나의 버퍼만 바인딩될 수 있습니다. 버퍼를 바인딩하면 해당 타입에 대한 모든 후속 버퍼 작업이 현재 바인딩된 버퍼에 적용됩니다."
  example="glBindBuffer(GL_ARRAY_BUFFER, VBO);\n// 이제 GL_ARRAY_BUFFER 타겟에 대한 모든 작업이 VBO에 적용됩니다\n\n// 바인딩 해제\nglBindBuffer(GL_ARRAY_BUFFER, 0);"
  tags='["Buffer Management", "OpenGL State"]'
/> 콜을 저장해둡니다. 이는 VAO를 언바인드 하기 전에 EBO를 먼저 언바인드 하지 않도록 주의해야함을 의미합니다. 
그렇지 않으면 VAO는 EBO가 설정되지 않은 상태가 되버립니다. 

</Warning>

이제 초기화와 그리기 코드는 다음과 같이 보입니다. 

```cpp

// ..:: Initialization code :: ..
// 1. bind Vertex Array Object
glBindVertexArray(VAO);
// 2. copy our vertices array in a vertex buffer for OpenGL to use
glBindBuffer(GL_ARRAY_BUFFER, VBO);
glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW);
// 3. copy our index array in a element buffer for OpenGL to use
glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, EBO);
glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(indices), indices, GL_STATIC_DRAW);
// 4. then set the vertex attributes pointers
glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(float), (void*)0);
glEnableVertexAttribArray(0);  

[...]
  
// ..:: Drawing code (in render loop) :: ..
glUseProgram(shaderProgram);
glBindVertexArray(VAO);
glDrawElements(GL_TRIANGLES, 6, GL_UNSIGNED_INT, 0);
glBindVertexArray(0);
```

프로그램을 실행하면 아래 이미지 처럼 보여야합니다. 왼쪽 이미지는 익숙한 모습일테고 
오른쪽 이미지는 <Green>와이어프레임 모드(wireframe mode)</Green>로 그려진 것입니다. 
와이어프레임 사각형은 사각형이 정말 두개의 삼각형으로 그려졌다는 것을 알 수있습니다. 


![hellotriangle2](./images/getting-started/hellotriangle2.png)


<Info>
#### Wireframe mode 

삼각형을 와이어프레임 모드로 그리려면, <Func 
  name="glPolygonMode"
  params='[{"name":"face","type":"GLenum","description":"모드가 적용될 폴리곤을 지정합니다. GL_FRONT, GL_BACK, GL_FRONT_AND_BACK 값을 가질 수 있습니다."},{"name":"mode","type":"GLenum","description":"폴리곤이 어떻게 래스터화될지 지정합니다. GL_POINT, GL_LINE, GL_FILL 값을 가질 수 있습니다. 초기값은 앞면과 뒷면 폴리곤 모두 GL_FILL입니다."}]'
  description="OpenGL이 프리미티브를 그리는 방식인 폴리곤 래스터화 모드를 설정합니다. 개발자는 원한다면 프리미티브를 선이나 점으로 그리도록 선택할 수 있습니다. 이후의 모든 그리기 호출은 설정된 래스터화 모드를 사용합니다."
  example="glPolygonMode(GL_FRONT_AND_BACK, GL_LINE); // 와이어프레임 모드\nglPolygonMode(GL_FRONT_AND_BACK, GL_FILL); // 기본 모드"
  tags='["Drawing", "Rendering Mode"]'
/>을 사용해 OpenGL이 프리미티브를 그리는 방식을 설정할 수 있습니다. 
첫 번째 인자는 모든 삼각형의 앞면과 뒷면에 적용하겠다는 의미이고, 두 번째 인자는 삼각형을 선(Line)으로 그리라는 의미입니다.

이후의 모든 드로잉 호출은 삼각형을 와이어프레임 모드로 렌더링하게 되며, 기본 설정으로 되돌리려면 `glPolygonMode(GL_FRONT_AND_BACK, GL_FILL)`을 호출하면 됩니다.
</Info>


만약 오류가 있다면, 거꾸로 돌아가서 놓친 것이 없는지 확인해보세요. 완성된 소스 코드는 <LinkBlock url="https://learnopengl.com/code_viewer_gh.php?code=src/1.getting_started/2.2.hello_triangle_indexed/hello_triangle_indexed.cpp" text="여기" />에서 확인할 수 있습니다.

만약 우리가 했던 것처럼 삼각형이나 사각형을 그리는 데 성공했다면 축하합니다! 현대 OpenGL의 가장 어려운 부분 중 하나인 첫 번째 삼각형 그리기를 해냈습니다. 이 부분이 어려운 이유는 첫 번째 삼각형을 그리기 전에 많은 지식이 필요하기 때문입니다. 다행히 이제 그 장벽을 넘었으므로, 앞으로의 장들은 훨씬 더 이해하기 쉬울 것입니다.

## 추가 자료

<List 
  items={[
    <><LinkBlock url="https://antongerdelan.net/hellotriangle" text="antongerdelan.net/hellotriangle" />: Anton Gerdelan의 첫 번째 삼각형 렌더링 접근법</>,
    <><LinkBlock url="https://open.gl/drawing" text="open.gl/drawing" />: Alexander Overvoorde의 첫 번째 삼각형 렌더링 접근법</>,
    <><LinkBlock url="https://antongerdelan.net/vertexbuffers" text="antongerdelan.net/vertexbuffers" />: 정점 버퍼 객체에 대한 추가적인 통찰</>,
    <><LinkBlock url="https://learnopengl.com/In-Practice/Debugging" text="learnopengl.com/In-Practice/Debugging" />: 이 장에는 많은 단계가 포함되어 있습니다. 막힌다면 OpenGL 디버깅에 대해 읽어보는 것이 도움이 될 수 있습니다 (debug output 섹션까지).</>
  ]}
/>

## 연습 문제

논의된 개념을 제대로 이해하기 위해 몇 가지 연습 문제가 준비되어 있습니다. 다음 주제로 넘어가기 전에 이 연습 문제들을 해결하여 무엇이 일어나고 있는지 제대로 이해하는 것이 좋습니다.

<NumberedList>
<NumberedItem>데이터에 더 많은 정점을 추가하여 <Func 
  name="glDrawArrays"
  params='[{"name":"mode","type":"GLenum","description":"그릴 프리미티브의 종류를 지정합니다."},{"name":"first","type":"GLint","description":"시작 인덱스를 지정합니다."},{"name":"count","type":"GLsizei","description":"렌더링할 정점의 개수를 지정합니다."}]'
  description="정점 배열로부터 프리미티브를 그립니다."
  example="glDrawArrays(GL_TRIANGLES, 0, 6);"
  tags='["Drawing"]'
/>를 사용하여 나란히 있는 2개의 삼각형을 그려보세요: <LinkBlock url="https://learnopengl.com/code_viewer_gh.php?code=src/1.getting_started/2.3.hello_triangle_exercise1/hello_triangle_exercise1.cpp" text="해답" />.</NumberedItem>
<NumberedItem>이제 각각의 데이터에 대해 서로 다른 VAO와 VBO를 사용하여 같은 2개의 삼각형을 만들어보세요: <LinkBlock url="https://learnopengl.com/code_viewer_gh.php?code=src/1.getting_started/2.4.hello_triangle_exercise2/hello_triangle_exercise2.cpp" text="해답" />.</NumberedItem>
<NumberedItem>두 번째 프로그램이 노란색을 출력하는 다른 프래그먼트 쉐이더를 사용하는 두 개의 쉐이더 프로그램을 만들어보세요. 하나는 노란색을 출력하도록 하여 두 삼각형을 다시 그려보세요: <LinkBlock url="https://learnopengl.com/code_viewer_gh.php?code=src/1.getting_started/2.5.hello_triangle_exercise3/hello_triangle_exercise3.cpp" text="해답" />.</NumberedItem>
</NumberedList>

